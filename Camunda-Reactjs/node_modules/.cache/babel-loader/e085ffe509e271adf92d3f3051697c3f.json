{"ast":null,"code":"var CLASS_PATTERN = /^class /;\n\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n  fn.$inject = args;\n  return fn;\n} // Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^(?:async )?(?:function\\s*)?[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\nfunction parseAnnotations(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS); // may parse class without constructor\n\n  if (!match) {\n    return [];\n  }\n\n  return match[1] && match[1].split(',').map(function (arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n}\n\nfunction Module() {\n  var providers = [];\n\n  this.factory = function (name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n\n  this.value = function (name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n\n  this.type = function (name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n\n  this.forEach = function (iterator) {\n    providers.forEach(iterator);\n  };\n}\n\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function (name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n  var self = instances.injector = this;\n\n  var error = function (msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n\n\n  var get = function (name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  };\n\n  var fnDef = function (fn, locals) {\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject || parseAnnotations(fn);\n    var dependencies = inject.map(function (dep) {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  };\n\n  var instantiate = function (Type) {\n    var def = fnDef(Type);\n    var fn = def.fn,\n        dependencies = def.dependencies; // instantiate var args constructor\n\n    var Constructor = Function.prototype.bind.apply(fn, [null].concat(dependencies));\n    return new Constructor();\n  };\n\n  var invoke = function (func, context, locals) {\n    var def = fnDef(func, locals);\n    var fn = def.fn,\n        dependencies = def.dependencies;\n    return fn.apply(context, dependencies);\n  };\n\n  var createPrivateInjectorFactory = function (privateChildInjector) {\n    return annotate(function (key) {\n      return privateChildInjector.get(key);\n    });\n  };\n\n  var createChild = function (modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function (scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function (scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function (value) {\n      return value;\n    }\n  };\n  modules.forEach(function (module) {\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n\n      return value;\n    } // TODO(vojta): handle wrong inputs (modules)\n\n\n    if (module instanceof Module) {\n      module.forEach(function (provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if (typeof module === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function (m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n\n          return m;\n        }, Object.create(null));\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function (key) {\n          return privateInjector.get(key);\n        });\n\n        module.__exports__.forEach(function (key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function (name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n\n          var type = module[name][0];\n          var value = module[name][1];\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  }); // public API\n\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n}\n\nexport { annotate, parseAnnotations, Module, Injector };","map":{"version":3,"names":["CLASS_PATTERN","isClass","fn","test","toString","isArray","obj","Object","prototype","call","hasOwnProp","prop","hasOwnProperty","annotate","args","Array","slice","arguments","length","pop","$inject","CONSTRUCTOR_ARGS","FN_ARGS","FN_ARG","parseAnnotations","Error","match","split","map","arg","trim","Module","providers","factory","name","push","value","type","forEach","iterator","Injector","modules","parent","get","strict","currentlyResolving","error","_providers","create","instances","_instances","self","injector","msg","stack","join","indexOf","parts","pivot","shift","fnDef","locals","inject","dependencies","dep","instantiate","Type","def","Constructor","Function","bind","apply","concat","invoke","func","context","createPrivateInjectorFactory","privateChildInjector","key","createChild","forceNewInstances","fromParentModule","matchedScopes","privateInjectorsCache","privateChildInjectors","privateChildFactories","provider","cacheIdx","privateChildInjectorFactory","$scope","scope","unshift","factoryMap","module","arrayUnwrap","__exports__","clonedModule","keys","reduce","m","substring","privateInjector","__modules__","getFromPrivateInjector"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/node_modules/didi/dist/index.esm.js"],"sourcesContent":["var CLASS_PATTERN = /^class /;\n\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^(?:async )?(?:function\\s*)?[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\nfunction parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  return match[1] && match[1].split(',').map(function(arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n}\n\nfunction Module() {\n  var providers = [];\n\n  this.factory = function(name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n\n  this.value = function(name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n\n  this.type = function(name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n\n  this.forEach = function(iterator) {\n    providers.forEach(iterator);\n  };\n\n}\n\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  var self = instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n  var get = function(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  };\n\n  var fnDef = function(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject || parseAnnotations(fn);\n    var dependencies = inject.map(function(dep) {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  };\n\n  var instantiate = function(Type) {\n    var def = fnDef(Type);\n\n    var fn = def.fn,\n        dependencies = def.dependencies;\n\n    // instantiate var args constructor\n    var Constructor = Function.prototype.bind.apply(fn, [ null ].concat(dependencies));\n\n    return new Constructor();\n  };\n\n  var invoke = function(func, context, locals) {\n    var def = fnDef(func, locals);\n\n    var fn = def.fn,\n        dependencies = def.dependencies;\n\n    return fn.apply(context, dependencies);\n  };\n\n\n  var createPrivateInjectorFactory = function(privateChildInjector) {\n    return annotate(function(key) {\n      return privateChildInjector.get(key);\n    });\n  };\n\n  var createChild = function(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function(scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function(scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  modules.forEach(function(module) {\n\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n\n      return value;\n    }\n\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function(provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if (typeof module === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function(m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n          return m;\n        }, Object.create(null));\n\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function(key) {\n          return privateInjector.get(key);\n        });\n        module.__exports__.forEach(function(key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function(name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n\n          var type = module[name][0];\n          var value = module[name][1];\n\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n}\n\nexport { annotate, parseAnnotations, Module, Injector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}