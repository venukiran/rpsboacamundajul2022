{"ast":null,"code":"import { forEach, bind, pick, assign, isString, isObject } from 'min-dash';\n/**\n * Moddle base element.\n */\n\nfunction Base() {}\n\nBase.prototype.get = function (name) {\n  return this.$model.properties.get(this, name);\n};\n\nBase.prototype.set = function (name, value) {\n  this.$model.properties.set(this, name, value);\n};\n/**\n * A model element factory.\n *\n * @param {Moddle} model\n * @param {Properties} properties\n */\n\n\nfunction Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\n\nFactory.prototype.createType = function (descriptor) {\n  var model = this.model;\n  var props = this.properties,\n      prototype = Object.create(Base.prototype); // initialize default values\n\n  forEach(descriptor.properties, function (p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n  var name = descriptor.ns.name;\n  /**\n   * The new type constructor\n   */\n\n  function ModdleElement(attrs) {\n    props.define(this, '$type', {\n      value: name,\n      enumerable: true\n    });\n    props.define(this, '$attrs', {\n      value: {}\n    });\n    props.define(this, '$parent', {\n      writable: true\n    });\n    forEach(attrs, bind(function (val, key) {\n      this.set(key, val);\n    }, this));\n  }\n\n  ModdleElement.prototype = prototype;\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType; // static links\n\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n  return ModdleElement;\n};\n/**\n * Built-in moddle types\n */\n\n\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n/**\n * Converters for built in types from string representations\n */\n\nvar TYPE_CONVERTERS = {\n  String: function (s) {\n    return s;\n  },\n  Boolean: function (s) {\n    return s === 'true';\n  },\n  Integer: function (s) {\n    return parseInt(s, 10);\n  },\n  Real: function (s) {\n    return parseFloat(s);\n  }\n};\n/**\n * Convert a type to its real representation\n */\n\nfunction coerceType(type, value) {\n  var converter = TYPE_CONVERTERS[type];\n\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n}\n/**\n * Return whether the given type is built-in\n */\n\n\nfunction isBuiltIn(type) {\n  return !!BUILTINS[type];\n}\n/**\n * Return whether the given type is simple\n */\n\n\nfunction isSimple(type) {\n  return !!TYPE_CONVERTERS[type];\n}\n/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\n\n\nfunction parseName(name, defaultPrefix) {\n  var parts = name.split(/:/),\n      localName,\n      prefix; // no prefix (i.e. only local name)\n\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  } else // prefix + local name\n    if (parts.length === 2) {\n      localName = parts[1];\n      prefix = parts[0];\n    } else {\n      throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n    }\n\n  name = (prefix ? prefix + ':' : '') + localName;\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n}\n/**\n * A utility to build element descriptors.\n */\n\n\nfunction DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\nDescriptorBuilder.prototype.build = function () {\n  return pick(this, ['ns', 'name', 'allTypes', 'allTypesByName', 'properties', 'propertiesByName', 'bodyProperty', 'idProperty']);\n};\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\n\n\nDescriptorBuilder.prototype.addProperty = function (p, idx, validate) {\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\nDescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error('property <' + newProperty.ns.name + '> must be id property ' + 'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n    if (!newProperty.isBody) {\n      throw new Error('property <' + newProperty.ns.name + '> must be body property ' + 'to refine <' + oldProperty.ns.name + '>');\n    } // TODO: Check compatibility\n\n\n    this.setBodyProperty(newProperty, false);\n  } // validate existence and get location of old property\n\n\n  var idx = props.indexOf(oldProperty);\n\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  } // remove old property\n\n\n  props.splice(idx, 1); // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n\n  this.addProperty(newProperty, replace ? undefined : idx, rename); // make new property available under old name\n\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\nDescriptorBuilder.prototype.redefineProperty = function (p, targetPropertyName, replace) {\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n  var name = parseName(parts[0], nsPrefix);\n  var attrName = parseName(parts[1], name.prefix).name;\n  var redefinedProperty = this.propertiesByName[attrName];\n\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function (p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function (p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function (p, validate) {\n  if (validate && this.bodyProperty) {\n    throw new Error('body property defined multiple times ' + '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function (p, validate) {\n  if (validate && this.idProperty) {\n    throw new Error('id property defined multiple times ' + '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function (p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error('property <' + propertyName + '> already defined; ' + 'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' + '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function (name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function (t, inherited) {\n  var typesByName = this.allTypesByName,\n      types = this.allTypes;\n  var typeName = t.name;\n\n  if (typeName in typesByName) {\n    return;\n  }\n\n  forEach(t.properties, bind(function (p) {\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n    var replaces = p.replaces,\n        redefines = p.redefines; // add replace/redefine support\n\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n\n      this.addProperty(p);\n    }\n  }, this));\n  types.push(t);\n  typesByName[typeName] = t;\n};\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\n\n\nfunction Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n  this.packages = [];\n  this.properties = properties;\n  forEach(packages, bind(this.registerPackage, this));\n}\n\nRegistry.prototype.getPackage = function (uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function () {\n  return this.packages;\n};\n\nRegistry.prototype.registerPackage = function (pkg) {\n  // copy package\n  pkg = assign({}, pkg);\n  var pkgMap = this.packageMap;\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri'); // register types\n\n  forEach(pkg.types, bind(function (descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n/**\n * Register a type from a specific package with us\n */\n\n\nRegistry.prototype.registerType = function (type, pkg) {\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign(type.meta || {})\n  });\n  var ns = parseName(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {}; // parse properties\n\n  forEach(type.properties, bind(function (p) {\n    // namespace property names\n    var propertyNs = parseName(p.name, ns.prefix),\n        propertyName = propertyNs.name; // namespace property types\n\n    if (!isBuiltIn(p.type)) {\n      p.type = parseName(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n    propertiesByName[propertyName] = p;\n  }, this)); // update ns + name\n\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n  forEach(type.extends, bind(function (extendsName) {\n    var extended = this.typeMap[extendsName];\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this)); // link to package\n\n  this.definePackage(type, pkg); // register\n\n  this.typeMap[name] = type;\n};\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\n\n\nRegistry.prototype.mapTypes = function (nsName, iterator, trait) {\n  var type = isBuiltIn(nsName.name) ? {\n    name: nsName.name\n  } : this.typeMap[nsName.name];\n  var self = this;\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n\n  function traverseTrait(cls) {\n    return traverseSuper(cls, true);\n  }\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n\n\n  function traverseSuper(cls, trait) {\n    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper); // call iterator with (type, inherited=!trait)\n\n  iterator(type, !trait);\n  forEach(type.traits, traverseTrait);\n};\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\n\n\nRegistry.prototype.getEffectiveDescriptor = function (name) {\n  var nsName = parseName(name);\n  var builder = new DescriptorBuilder(nsName);\n  this.mapTypes(nsName, function (type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n  var descriptor = builder.build(); // define package link\n\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n  return descriptor;\n};\n\nRegistry.prototype.definePackage = function (target, pkg) {\n  this.properties.define(target, '$pkg', {\n    value: pkg\n  });\n}; ///////// helpers ////////////////////////////\n\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n  var value = pkg[identifierKey];\n\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\n\n\nfunction Properties(model) {\n  this.model = model;\n}\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\n\n\nProperties.prototype.set = function (target, name, value) {\n  var property = this.model.getPropertyDescriptor(target, name);\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[name];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[name] = value;\n    }\n  }\n};\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\n\n\nProperties.prototype.get = function (target, name) {\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  if (!property) {\n    return target.$attrs[name];\n  }\n\n  var propertyName = property.name; // check if access to collection property and lazily initialize it\n\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\n\n\nProperties.prototype.define = function (target, name, options) {\n  if (!options.writable) {\n    var value = options.value; // use getters for read-only variables to support ES6 proxies\n    // cf. https://github.com/bpmn-io/internal-docs/issues/386\n\n    options = assign({}, options, {\n      get: function () {\n        return value;\n      }\n    });\n    delete options.value;\n  }\n\n  Object.defineProperty(target, name, options);\n};\n/**\n * Define the descriptor for an element\n */\n\n\nProperties.prototype.defineDescriptor = function (target, descriptor) {\n  this.define(target, '$descriptor', {\n    value: descriptor\n  });\n};\n/**\n * Define the model for an element\n */\n\n\nProperties.prototype.defineModel = function (target, model) {\n  this.define(target, '$model', {\n    value: model\n  });\n};\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n} //// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n */\n\n\nfunction Moddle(packages) {\n  this.properties = new Properties(this);\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n  this.typeCache = {};\n}\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\n\n\nModdle.prototype.create = function (descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\n\n\nModdle.prototype.getType = function (descriptor) {\n  var cache = this.typeCache;\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\n\n\nModdle.prototype.createAny = function (name, nsUri, properties) {\n  var nameNs = parseName(name);\n  var element = {\n    $type: name,\n    $instanceOf: function (type) {\n      return type === this.$type;\n    }\n  };\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, '$parent', {\n    enumerable: false,\n    writable: true\n  });\n  this.properties.define(element, '$instanceOf', {\n    enumerable: false,\n    writable: true\n  });\n  forEach(properties, function (a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n  return element;\n};\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\n\n\nModdle.prototype.getPackage = function (uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\n\n\nModdle.prototype.getPackages = function () {\n  return this.registry.getPackages();\n};\n/**\n * Returns the descriptor for an element\n */\n\n\nModdle.prototype.getElementDescriptor = function (element) {\n  return element.$descriptor;\n};\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\n\n\nModdle.prototype.hasType = function (element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n  return type in descriptor.allTypesByName;\n};\n/**\n * Returns the descriptor of an elements named property\n */\n\n\nModdle.prototype.getPropertyDescriptor = function (element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n/**\n * Returns a mapped type's descriptor\n */\n\n\nModdle.prototype.getTypeDescriptor = function (type) {\n  return this.registry.typeMap[type];\n};\n\nexport { Moddle, coerceType, isBuiltIn as isBuiltInType, isSimple as isSimpleType, parseName as parseNameNS };","map":{"version":3,"names":["forEach","bind","pick","assign","isString","isObject","Base","prototype","get","name","$model","properties","set","value","Factory","model","createType","descriptor","props","Object","create","p","isMany","default","undefined","defineModel","defineDescriptor","ns","ModdleElement","attrs","define","enumerable","writable","val","key","hasType","$instanceOf","BUILTINS","String","Boolean","Integer","Real","Element","TYPE_CONVERTERS","s","parseInt","parseFloat","coerceType","type","converter","isBuiltIn","isSimple","parseName","defaultPrefix","parts","split","localName","prefix","length","Error","DescriptorBuilder","nameNs","allTypes","allTypesByName","propertiesByName","build","addProperty","idx","validate","addNamedProperty","splice","push","replaceProperty","oldProperty","newProperty","replace","oldNameNs","rename","isId","setIdProperty","isBody","setBodyProperty","indexOf","redefineProperty","targetPropertyName","nsPrefix","attrName","redefinedProperty","redefines","propsByName","assertNotDefined","removeNamedProperty","bodyProperty","idProperty","propertyName","definedProperty","definedBy","hasProperty","addTrait","t","inherited","typesByName","types","typeName","defineProperty","replaces","Registry","packages","packageMap","typeMap","registerPackage","getPackage","uriOrPrefix","getPackages","pkg","pkgMap","ensureAvailable","registerType","uri","superClass","slice","extends","meta","propertyNs","extendsName","extended","traits","definePackage","mapTypes","nsName","iterator","trait","self","traverseTrait","cls","traverseSuper","parentNs","getEffectiveDescriptor","builder","$pkg","target","identifierKey","Properties","property","getPropertyDescriptor","isUndefined","$attrs","options","isReference","configurable","Moddle","factory","registry","typeCache","Type","getType","cache","createAny","nsUri","element","$type","isGeneric","a","getElementDescriptor","$descriptor","getTypeDescriptor","isBuiltInType","isSimpleType","parseNameNS"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/node_modules/moddle/dist/index.esm.js"],"sourcesContent":["import { forEach, bind, pick, assign, isString, isObject } from 'min-dash';\n\n/**\n * Moddle base element.\n */\nfunction Base() { }\n\nBase.prototype.get = function(name) {\n  return this.$model.properties.get(this, name);\n};\n\nBase.prototype.set = function(name, value) {\n  this.$model.properties.set(this, name, value);\n};\n\n/**\n * A model element factory.\n *\n * @param {Moddle} model\n * @param {Properties} properties\n */\nfunction Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\n\n\nFactory.prototype.createType = function(descriptor) {\n\n  var model = this.model;\n\n  var props = this.properties,\n      prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  forEach(descriptor.properties, function(p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', { value: name, enumerable: true });\n    props.define(this, '$attrs', { value: {} });\n    props.define(this, '$parent', { writable: true });\n\n    forEach(attrs, bind(function(val, key) {\n      this.set(key, val);\n    }, this));\n  }\n\n  ModdleElement.prototype = prototype;\n\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n\n  return ModdleElement;\n};\n\n/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function(s) { return s; },\n  Boolean: function(s) { return s === 'true'; },\n  Integer: function(s) { return parseInt(s, 10); },\n  Real: function(s) { return parseFloat(s); }\n};\n\n/**\n * Convert a type to its real representation\n */\nfunction coerceType(type, value) {\n\n  var converter = TYPE_CONVERTERS[type];\n\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n}\n\n/**\n * Return whether the given type is built-in\n */\nfunction isBuiltIn(type) {\n  return !!BUILTINS[type];\n}\n\n/**\n * Return whether the given type is simple\n */\nfunction isSimple(type) {\n  return !!TYPE_CONVERTERS[type];\n}\n\n/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nfunction parseName(name, defaultPrefix) {\n  var parts = name.split(/:/),\n      localName, prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  } else\n  // prefix + local name\n  if (parts.length === 2) {\n    localName = parts[1];\n    prefix = parts[0];\n  } else {\n    throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n  }\n\n  name = (prefix ? prefix + ':' : '') + localName;\n\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n}\n\n/**\n * A utility to build element descriptors.\n */\nfunction DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\n\nDescriptorBuilder.prototype.build = function() {\n  return pick(this, [\n    'ns',\n    'name',\n    'allTypes',\n    'allTypesByName',\n    'properties',\n    'propertiesByName',\n    'bodyProperty',\n    'idProperty'\n  ]);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\n\nDescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be id property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n\n    if (!newProperty.isBody) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be body property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\n\nDescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n\n  var name = parseName(parts[0], nsPrefix);\n  var attrName = parseName(parts[1], name.prefix).name;\n\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function(p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n  if (validate && this.bodyProperty) {\n    throw new Error(\n      'body property defined multiple times ' +\n      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n  if (validate && this.idProperty) {\n    throw new Error(\n      'id property defined multiple times ' +\n      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error(\n      'property <' + propertyName + '> already defined; ' +\n      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function(name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n  var typesByName = this.allTypesByName,\n      types = this.allTypes;\n\n  var typeName = t.name;\n\n  if (typeName in typesByName) {\n    return;\n  }\n\n  forEach(t.properties, bind(function(p) {\n\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n\n    var replaces = p.replaces,\n        redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this));\n\n  types.push(t);\n  typesByName[typeName] = t;\n};\n\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\nfunction Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n\n  this.packages = [];\n\n  this.properties = properties;\n\n  forEach(packages, bind(this.registerPackage, this));\n}\n\n\nRegistry.prototype.getPackage = function(uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function() {\n  return this.packages;\n};\n\n\nRegistry.prototype.registerPackage = function(pkg) {\n\n  // copy package\n  pkg = assign({}, pkg);\n\n  var pkgMap = this.packageMap;\n\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri');\n\n  // register types\n  forEach(pkg.types, bind(function(descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function(type, pkg) {\n\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign((type.meta || {}))\n  });\n\n  var ns = parseName(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, bind(function(p) {\n\n    // namespace property names\n    var propertyNs = parseName(p.name, ns.prefix),\n        propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltIn(p.type)) {\n      p.type = parseName(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n\n    propertiesByName[propertyName] = p;\n  }, this));\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n\n  forEach(type.extends, bind(function(extendsName) {\n    var extended = this.typeMap[extendsName];\n\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this));\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n  var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n  var self = this;\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverseSuper(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverseSuper(cls, trait) {\n    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n\n  forEach(type.traits, traverseTrait);\n};\n\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function(name) {\n\n  var nsName = parseName(name);\n\n  var builder = new DescriptorBuilder(nsName);\n\n  this.mapTypes(nsName, function(type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n  return descriptor;\n};\n\n\nRegistry.prototype.definePackage = function(target, pkg) {\n  this.properties.define(target, '$pkg', { value: pkg });\n};\n\n\n\n///////// helpers ////////////////////////////\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n\n  var value = pkg[identifierKey];\n\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nfunction Properties(model) {\n  this.model = model;\n}\n\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function(target, name, value) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[name];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[name] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function(target, name) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  if (!property) {\n    return target.$attrs[name];\n  }\n\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function(target, name, options) {\n\n  if (!options.writable) {\n\n    var value = options.value;\n\n    // use getters for read-only variables to support ES6 proxies\n    // cf. https://github.com/bpmn-io/internal-docs/issues/386\n    options = assign({}, options, {\n      get: function() { return value; }\n    });\n\n    delete options.value;\n  }\n\n  Object.defineProperty(target, name, options);\n};\n\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function(target, descriptor) {\n  this.define(target, '$descriptor', { value: descriptor });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function(target, model) {\n  this.define(target, '$model', { value: model });\n};\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}\n\n//// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n */\nfunction Moddle(packages) {\n\n  this.properties = new Properties(this);\n\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n\n  this.typeCache = {};\n}\n\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function(descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function(descriptor) {\n\n  var cache = this.typeCache;\n\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function(name, nsUri, properties) {\n\n  var nameNs = parseName(name);\n\n  var element = {\n    $type: name,\n    $instanceOf: function(type) {\n      return type === this.$type;\n    }\n  };\n\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, '$parent', { enumerable: false, writable: true });\n  this.properties.define(element, '$instanceOf', { enumerable: false, writable: true });\n\n  forEach(properties, function(a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function(uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function() {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function(element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function(element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n\n  return (type in descriptor.allTypesByName);\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function(element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function(type) {\n  return this.registry.typeMap[type];\n};\n\nexport { Moddle, coerceType, isBuiltIn as isBuiltInType, isSimple as isSimpleType, parseName as parseNameNS };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}