{"ast":null,"code":"import { normalize, schema } from 'normalizr';\nimport { camelizeKeys } from 'humps';\nconst API_ROOT = 'http://localhost:7070/engine-rest/'; // Fetches an API response and normalizes the result JSON according to schema.\n// This makes every API response have the same shape, regardless of how nested it was.\n\nconst callApi = function (endpoint, schema) {\n  let settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const fullUrl = endpoint.indexOf(API_ROOT) === -1 ? API_ROOT + endpoint : endpoint;\n  return fetch(fullUrl, settings).then(response => response.json().then(json => {\n    if (!response.ok) {\n      return Promise.reject(json);\n    }\n\n    const camelizedJson = camelizeKeys(json);\n    return Object.assign({}, normalize(camelizedJson, schema), {});\n  }));\n}; // We use this Normalizr schemas to transform API responses from a nested form\n// to a flat form where repos and users are placed in `entities`, and nested\n// JSON objects are replaced with their IDs. This is very convenient for\n// consumption by reducers, because we can easily build a normalized tree\n// and keep it updated as we fetch more data.\n// Read more about Normalizr: https://github.com/paularmstrong/normalizr\n\n\nconst processDefinitionSchema = new schema.Entity('processDefinition', {}, {\n  id: processDefinition => processDefinition.id,\n  name: processDefinition => processDefinition.name\n});\nconst processDefinitionXMLSchema = new schema.Entity('processDefinitionXML', {}, {});\nconst formKeySchema = new schema.Entity('formKey', {}, {\n  idAttribute: 'test'\n});\nconst processInstanceStartedSchema = new schema.Entity('processInstanceStarted', {}, {});\nconst taskSchema = new schema.Entity('task', {}, {\n  id: task => task.id\n});\nconst taskVariableSchema = new schema.Entity('taskVariable', {}, {\n  processStrategy: (value, parent, key) => {\n    return {\n      values: value,\n      test: key,\n      parent: parent\n    };\n  }\n});\nconst taskVariableArraySchema = new schema.Entity('taskVariables', {}, {\n  idAttribute: variable => 'variables',\n  processStrategy: (value, parent, key) => {\n    let values = {};\n    Object.keys(value).forEach(item => {\n      values[item] = value[item].value;\n    });\n    return values;\n  }\n});\nconst processDeploymentSchema = new schema.Entity('processDeployment', {}, {}); // Schemas for Github API responses.\n\nexport const Schemas = {\n  PROCESS_DEFINITION: processDefinitionSchema,\n  PROCESS_DEFINITION_ARRAY: [processDefinitionSchema],\n  PROCESS_DEFINITION_XML: processDefinitionXMLSchema,\n  FORM_KEY: formKeySchema,\n  TASK: taskSchema,\n  TASK_ARRAY: [taskSchema],\n  PROCESS_INSTANCE_STARTED: processInstanceStartedSchema,\n  TASK_VARIABLE: taskVariableSchema,\n  TASK_VARIABLES: taskVariableArraySchema,\n  PROCESS_DEPLOYMENT: processDeploymentSchema\n}; // Action key that carries API call info interpreted by this Redux middleware.\n\nexport const CALL_API = 'Call API'; // A Redux middleware that interprets actions with CALL_API info specified.\n// Performs the call and promises when such actions are dispatched.\n\nexport default (store => next => action => {\n  const callAPI = action[CALL_API];\n\n  if (typeof callAPI === 'undefined') {\n    return next(action);\n  }\n\n  let {\n    endpoint\n  } = callAPI;\n  const {\n    schema,\n    types,\n    settings\n  } = callAPI;\n\n  if (typeof endpoint === 'function') {\n    endpoint = endpoint(store.getState());\n  }\n\n  if (typeof endpoint !== 'string') {\n    throw new Error('Specify a string endpoint URL.');\n  }\n\n  if (!schema) {\n    throw new Error('Specify one of the exported Schemas.');\n  }\n\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected an array of three action types.');\n  }\n\n  if (!types.every(type => typeof type === 'string')) {\n    throw new Error('Expected action types to be strings.');\n  }\n\n  const actionWith = data => {\n    const finalAction = Object.assign({}, action, data);\n    delete finalAction[CALL_API];\n    return finalAction;\n  };\n\n  const [requestType, successType, failureType] = types;\n  next(actionWith({\n    type: requestType\n  }));\n  return callApi(endpoint, schema, settings).then(response => next(actionWith({\n    response,\n    type: successType\n  })), error => next(actionWith({\n    type: failureType,\n    error: error.message || 'Something bad happened'\n  })));\n});","map":{"version":3,"names":["normalize","schema","camelizeKeys","API_ROOT","callApi","endpoint","settings","fullUrl","indexOf","fetch","then","response","json","ok","Promise","reject","camelizedJson","Object","assign","processDefinitionSchema","Entity","id","processDefinition","name","processDefinitionXMLSchema","formKeySchema","idAttribute","processInstanceStartedSchema","taskSchema","task","taskVariableSchema","processStrategy","value","parent","key","values","test","taskVariableArraySchema","variable","keys","forEach","item","processDeploymentSchema","Schemas","PROCESS_DEFINITION","PROCESS_DEFINITION_ARRAY","PROCESS_DEFINITION_XML","FORM_KEY","TASK","TASK_ARRAY","PROCESS_INSTANCE_STARTED","TASK_VARIABLE","TASK_VARIABLES","PROCESS_DEPLOYMENT","CALL_API","store","next","action","callAPI","types","getState","Error","Array","isArray","length","every","type","actionWith","data","finalAction","requestType","successType","failureType","error","message"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/src/middleware/api.js"],"sourcesContent":["import { normalize, schema } from 'normalizr'\r\nimport { camelizeKeys } from 'humps'\r\n\r\nconst API_ROOT = 'http://localhost:7070/engine-rest/'\r\n\r\n// Fetches an API response and normalizes the result JSON according to schema.\r\n// This makes every API response have the same shape, regardless of how nested it was.\r\nconst callApi = (endpoint, schema, settings = {}) => {\r\n  const fullUrl = (endpoint.indexOf(API_ROOT) === -1) ? API_ROOT + endpoint : endpoint\r\n\r\n  return fetch(fullUrl, settings)\r\n    .then(response =>\r\n      response.json().then(json => {\r\n        if (!response.ok) {\r\n          return Promise.reject(json)\r\n        }\r\n\r\n        const camelizedJson = camelizeKeys(json)\r\n          return Object.assign({},\r\n          normalize(camelizedJson, schema),\r\n          {  }\r\n        )\r\n      })\r\n    )\r\n}\r\n\r\n// We use this Normalizr schemas to transform API responses from a nested form\r\n// to a flat form where repos and users are placed in `entities`, and nested\r\n// JSON objects are replaced with their IDs. This is very convenient for\r\n// consumption by reducers, because we can easily build a normalized tree\r\n// and keep it updated as we fetch more data.\r\n\r\n// Read more about Normalizr: https://github.com/paularmstrong/normalizr\r\n\r\nconst processDefinitionSchema = new schema.Entity('processDefinition', {}, {\r\n  id: processDefinition => processDefinition.id,\r\n  name: processDefinition => processDefinition.name\r\n})\r\n\r\nconst processDefinitionXMLSchema = new schema.Entity('processDefinitionXML', {}, {\r\n\r\n});\r\n\r\nconst formKeySchema = new schema.Entity('formKey', {}, {\r\n  idAttribute: 'test',\r\n});\r\n\r\nconst processInstanceStartedSchema = new schema.Entity('processInstanceStarted', {}, {\r\n\r\n});\r\n\r\nconst taskSchema = new schema.Entity('task', {}, {\r\n  id: task => task.id,\r\n});\r\n\r\nconst taskVariableSchema = new schema.Entity('taskVariable', {}, {\r\n  processStrategy: (value, parent, key) => {\r\n    return {\r\n      values: value,\r\n      test: key,\r\n      parent: parent\r\n    }\r\n  }\r\n})\r\nconst taskVariableArraySchema = new schema.Entity('taskVariables', {}, {\r\n  idAttribute: variable => 'variables',\r\n  processStrategy: (value, parent, key) => {\r\n    let values = {};\r\n    Object.keys(value).forEach((item) => {\r\n      values[item] = value[item].value\r\n    })\r\n    return values\r\n  }\r\n})\r\n\r\nconst processDeploymentSchema = new schema.Entity('processDeployment', {}, {})\r\n\r\n// Schemas for Github API responses.\r\nexport const Schemas = {\r\n  PROCESS_DEFINITION: processDefinitionSchema,\r\n  PROCESS_DEFINITION_ARRAY: [processDefinitionSchema],\r\n  PROCESS_DEFINITION_XML: processDefinitionXMLSchema,\r\n  FORM_KEY: formKeySchema,\r\n  TASK: taskSchema,\r\n  TASK_ARRAY: [taskSchema],\r\n  PROCESS_INSTANCE_STARTED: processInstanceStartedSchema,\r\n  TASK_VARIABLE: taskVariableSchema,\r\n  TASK_VARIABLES: taskVariableArraySchema,\r\n  PROCESS_DEPLOYMENT: processDeploymentSchema\r\n}\r\n\r\n// Action key that carries API call info interpreted by this Redux middleware.\r\nexport const CALL_API = 'Call API'\r\n\r\n// A Redux middleware that interprets actions with CALL_API info specified.\r\n// Performs the call and promises when such actions are dispatched.\r\nexport default store => next => action => {\r\n  const callAPI = action[CALL_API]\r\n\r\n  if (typeof callAPI === 'undefined') {\r\n    return next(action)\r\n  }\r\n\r\n  let { endpoint } = callAPI\r\n  const { schema, types, settings } = callAPI\r\n\r\n  if (typeof endpoint === 'function') {\r\n    endpoint = endpoint(store.getState())\r\n  }\r\n\r\n  if (typeof endpoint !== 'string') {\r\n    throw new Error('Specify a string endpoint URL.')\r\n  }\r\n  if (!schema) {\r\n    throw new Error('Specify one of the exported Schemas.')\r\n  }\r\n  if (!Array.isArray(types) || types.length !== 3) {\r\n    throw new Error('Expected an array of three action types.')\r\n  }\r\n  if (!types.every(type => typeof type === 'string')) {\r\n    throw new Error('Expected action types to be strings.')\r\n  }\r\n\r\n  const actionWith = data => {\r\n    const finalAction = Object.assign({}, action, data)\r\n    delete finalAction[CALL_API]\r\n    return finalAction\r\n  }\r\n\r\n  const [ requestType, successType, failureType ] = types\r\n  next(actionWith({ type: requestType }))\r\n\r\n  return callApi(endpoint, schema, settings).then(\r\n    response => next(actionWith({\r\n      response,\r\n      type: successType\r\n    })),\r\n    error => next(actionWith({\r\n      type: failureType,\r\n      error: error.message || 'Something bad happened'\r\n    }))\r\n  )\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}