{"ast":null,"code":"var fromCharCode = String.fromCharCode;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n}; // map UPPERCASE variants of supported special chars\n\nObject.keys(ENTITY_MAPPING).forEach(function (k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\n\nfunction replaceEntities(_, d, x, z) {\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  } // decimal encoded char\n\n\n  if (d) {\n    return fromCharCode(d);\n  } // hex encoded char\n\n\n  return fromCharCode(parseInt(x, 16));\n}\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} str\n *\n * @return {string} decoded string\n */\n\n\nfunction decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n\n  return s;\n}\n\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\nvar XSI_PREFIX = 'xsi';\nvar XSI_TYPE = 'xsi:type';\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\n\nfunction error(msg) {\n  return new Error(msg);\n}\n\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\n\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\n\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {},\n      key;\n\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n\n  return clone;\n}\n\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\n\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n      uri,\n      prefix;\n\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n\n  return nsMatrix;\n}\n\nfunction noopGetContext() {\n  return {\n    'line': 0,\n    'column': 0\n  };\n}\n\nfunction throwFunc(err) {\n  throw err;\n}\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\n\n\nfunction Parser(options) {\n  if (!this) {\n    return new Parser(options);\n  }\n\n  var proxy = options && options['proxy'];\n  var onText,\n      onOpenTag,\n      onCloseTag,\n      onCDATA,\n      onError = throwFunc,\n      onWarning,\n      onComment,\n      onQuestion,\n      onAttention;\n  var getContext = noopGetContext;\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n\n  var maybeNS = false;\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n\n  var isNamespace = false;\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n\n  var returnError = null;\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n\n  var parseStop = false;\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n\n  var nsUriToPrefix;\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    returnError = err;\n    onError(err, getContext);\n  }\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n\n\n  function handleWarning(err) {\n    if (!onWarning) {\n      return;\n    }\n\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    onWarning(err, getContext);\n  }\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n\n\n  this['on'] = function (name, cb) {\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n\n    switch (name) {\n      case 'openTag':\n        onOpenTag = cb;\n        break;\n\n      case 'text':\n        onText = cb;\n        break;\n\n      case 'closeTag':\n        onCloseTag = cb;\n        break;\n\n      case 'error':\n        onError = cb;\n        break;\n\n      case 'warn':\n        onWarning = cb;\n        break;\n\n      case 'cdata':\n        onCDATA = cb;\n        break;\n\n      case 'attention':\n        onAttention = cb;\n        break;\n      // <!XXXXX zzzz=\"eeee\">\n\n      case 'question':\n        onQuestion = cb;\n        break;\n      // <? ....  ?>\n\n      case 'comment':\n        onComment = cb;\n        break;\n\n      default:\n        throw error('unsupported event: ' + name);\n    }\n\n    return this;\n  };\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n\n\n  this['ns'] = function (nsMap) {\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n\n    var _nsUriToPrefix = {},\n        k;\n\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    } // FORCE default mapping for schema instance\n\n\n    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n    return this;\n  };\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n\n\n  this['parse'] = function (xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n\n    returnError = null;\n    parse(xml);\n    getContext = noopGetContext;\n    parseStop = false;\n    return returnError;\n  };\n  /**\n   * Stop parsing.\n   */\n\n\n  this['stop'] = function () {\n    parseStop = true;\n  };\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n\n\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n        _nsMatrix,\n        nodeStack = [],\n        anonymousNsCount = 0,\n        tagStart = false,\n        tagEnd = false,\n        i = 0,\n        j = 0,\n        x,\n        y,\n        q,\n        w,\n        v,\n        xmlns,\n        elementName,\n        _elementName,\n        elementProxy;\n\n    var attrsString = '',\n        attrsStart = 0,\n        cachedAttrs // false = parsed with errors, null = needs parsing\n    ;\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n\n      var nsUri,\n          nsUriPrefix,\n          nsName,\n          defaultAlias = isNamespace && nsMatrix['xmlns'],\n          attrList = isNamespace && maybeNS ? [] : null,\n          i = attrsStart,\n          s = attrsString,\n          l = s.length,\n          hasNewMatrix,\n          newalias,\n          value,\n          alias,\n          name,\n          attrs = {},\n          seenAttrs = {},\n          skipAttr,\n          w,\n          j;\n\n      parseAttr: for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n\n        if (w === 32 || w < 14 && w > 8) {\n          // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        } // wait for non whitespace character\n\n\n        if (w < 65 || w > 122 || w > 90 && w < 97) {\n          if (w !== 95 && w !== 58) {\n            // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        } // parse attribute name\n\n\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 46 || // '.'\n          w === 45 || // '-'\n          w === 95 // '_'\n          ) {\n            continue;\n          } // unexpected whitespace\n\n\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n            continue parseAttr;\n          } // expected \"=\"\n\n\n          if (w === 61) {\n            // \"=\" == 61\n            break;\n          }\n\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n\n        name = s.substring(i, j);\n\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n\n        w = s.charCodeAt(j + 1);\n\n        if (w === 34) {\n          // '\"'\n          j = s.indexOf('\"', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else if (w === 39) {\n          // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true; // skip to next space\n\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || w < 14 && w > 8) {\n              // WHITESPACE\n              break;\n            }\n          }\n        }\n\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n          j = l;\n          skipAttr = true;\n        }\n\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n\n        i = j; // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            break;\n          } // FIRST ILLEGAL CHAR\n\n\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        } // advance cursor to next attribute\n\n\n        i = j + 1;\n\n        if (skipAttr) {\n          continue parseAttr;\n        } // check attribute re-declaration\n\n\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n\n        seenAttrs[name] = true;\n\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        } // try to extract namespace information\n\n\n        if (maybeNS) {\n          newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' ? name.substr(6) : null; // handle xmlns(:alias) assignment\n\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n            alias = nsUriToPrefix[nsUri];\n\n            if (!alias) {\n              // no prefix defined or prefix collision\n              if (newalias === 'xmlns' || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + anonymousNsCount++;\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n\n              nsUriToPrefix[nsUri] = alias;\n            }\n\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n\n              nsMatrix[newalias] = alias;\n\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n\n              nsMatrix[nsUriPrefix] = nsUri;\n            } // expose xmlns(:asd)=\"...\" in attributes\n\n\n            attrs[name] = value;\n            continue;\n          } // collect attributes until all namespace\n          // declarations are processed\n\n\n          attrList.push(name, value);\n          continue;\n        }\n        /** end if (maybeNs) */\n        // handle attributes on element without\n        // namespace declarations\n\n\n        w = name.indexOf(':');\n\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        } // normalize ns attribute name\n\n\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n\n        name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w); // end: normalize ns attribute name\n        // normalize xsi:type ns attribute value\n\n        if (name === XSI_TYPE) {\n          w = value.indexOf(':');\n\n          if (w !== -1) {\n            nsName = value.substring(0, w); // handle default prefixes, i.e. xs:String gracefully\n\n            nsName = nsMatrix[nsName] || nsName;\n            value = nsName + value.substring(w);\n          } else {\n            value = defaultAlias + ':' + value;\n          }\n        } // end: normalize xsi:type ns attribute value\n\n\n        attrs[name] = value;\n      } // handle deferred, possibly namespaced attributes\n\n\n      if (maybeNS) {\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n          name = attrList[i++];\n          value = attrList[i];\n          w = name.indexOf(':');\n\n          if (w !== -1) {\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n\n            name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w); // end: normalize ns attribute name\n            // normalize xsi:type ns attribute value\n\n            if (name === XSI_TYPE) {\n              w = value.indexOf(':');\n\n              if (w !== -1) {\n                nsName = value.substring(0, w); // handle default prefixes, i.e. xs:String gracefully\n\n                nsName = nsMatrix[nsName] || nsName;\n                value = nsName + value.substring(w);\n              } else {\n                value = defaultAlias + ':' + value;\n              }\n            } // end: normalize xsi:type ns attribute value\n\n          }\n\n          attrs[name] = value;\n        } // end: normalize captured attributes\n\n      }\n\n      return cachedAttrs = attrs;\n    }\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n\n\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n\n      while (i >= startOfLine) {\n        match = splitsRe.exec(xml);\n\n        if (!match) {\n          break;\n        } // end of line = (break idx + break chars)\n\n\n        endOfLine = match[0].length + match.index;\n\n        if (endOfLine > i) {\n          break;\n        } // advance to next line\n\n\n        line += 1;\n        startOfLine = endOfLine;\n      } // EOF errors\n\n\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else // start errors\n        if (j === 0) {\n          data = xml.substring(j, i);\n        } // other errors\n        else {\n          column = i - startOfLine;\n          data = j == -1 ? xml.substring(i) : xml.substring(i, j + 1);\n        }\n\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n\n    getContext = getParseContext;\n\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function () {\n          return elementName;\n        }),\n        'originalName': getter(function () {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function () {\n          return nsMatrix;\n        })\n      });\n    } // actual parse logic\n\n\n    while (j !== -1) {\n      if (xml.charCodeAt(j) === 60) {\n        // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      } // parse end\n\n\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n\n        return;\n      } // parse text\n\n\n      if (j !== i) {\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n\n      w = xml.charCodeAt(i + 1); // parse comments + CDATA\n\n      if (w === 33) {\n        // \"!\"\n        q = xml.charCodeAt(i + 2); // CDATA section\n\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') {\n          // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        } // comment\n\n\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) {\n          // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n      } // parse question <? ... ?>\n\n\n      if (w === 63) {\n        // \"?\"\n        j = xml.indexOf('?>', i);\n\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 2;\n        continue;\n      } // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n\n\n      for (x = i + 1;; x++) {\n        v = xml.charCodeAt(x);\n\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        } // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n\n\n        if (v === 34) {\n          //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) {\n          // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) {\n          // '>'\n          j = x;\n          break;\n        }\n      } // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n\n\n      if (w === 33) {\n        // \"!\"\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 1;\n        continue;\n      } // don't process attributes;\n      // there are none\n\n\n      cachedAttrs = {}; // if (xml.charCodeAt(i+1) === 47) { // </...\n\n      if (w === 47) {\n        // </...\n        tagStart = false;\n        tagEnd = true;\n\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        } // verify open <-> close tag match\n\n\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        } // verify chars in close tag\n\n\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n\n          if (w === 32 || w > 8 && w < 14) {\n            // \\f\\n\\r\\t\\v space\n            continue;\n          }\n\n          return handleError('close tag');\n        }\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) {\n          // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n          tagStart = true;\n          tagEnd = true;\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n          tagStart = true;\n          tagEnd = false;\n        }\n\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {\n          // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n\n          if (w === 32 || w < 14 && w > 8) {\n            // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q); // maybe there are attributes\n\n            cachedAttrs = null;\n            break;\n          }\n\n          return handleError('invalid nodeName');\n        }\n\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n\n      if (isNamespace) {\n        _nsMatrix = nsMatrix;\n\n        if (tagStart) {\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n\n          if (cachedAttrs === null) {\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if (maybeNS = x.indexOf('xmlns', q) !== -1) {\n              attrsStart = q;\n              attrsString = x;\n              getAttrs();\n              maybeNS = false;\n            }\n          }\n        }\n\n        _elementName = elementName;\n        w = elementName.indexOf(':');\n\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)]; // prefix given; namespace must exist\n\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns']; // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        } // adjust namespace prefixs as configured\n\n\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n      }\n\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n\n          if (parseStop) {\n            return;\n          }\n        }\n      }\n\n      if (tagEnd) {\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        } // restore old namespace\n\n\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n\n      j += 1;\n    }\n  }\n  /** end parse */\n\n}\n\nexport { Parser, decodeEntities as decode };","map":{"version":3,"names":["fromCharCode","String","hasOwnProperty","Object","prototype","ENTITY_PATTERN","ENTITY_MAPPING","keys","forEach","k","toUpperCase","replaceEntities","_","d","x","z","call","parseInt","decodeEntities","s","length","indexOf","replace","XSI_URI","XSI_PREFIX","XSI_TYPE","NON_WHITESPACE_OUTSIDE_ROOT_NODE","error","msg","Error","missingNamespaceForPrefix","prefix","getter","getFn","cloneNsMatrix","nsMatrix","clone","key","uriPrefix","buildNsMatrix","nsUriToPrefix","uri","noopGetContext","throwFunc","err","Parser","options","proxy","onText","onOpenTag","onCloseTag","onCDATA","onError","onWarning","onComment","onQuestion","onAttention","getContext","maybeNS","isNamespace","returnError","parseStop","handleError","handleWarning","name","cb","nsMap","_nsUriToPrefix","xml","parse","nsMatrixStack","_nsMatrix","nodeStack","anonymousNsCount","tagStart","tagEnd","i","j","y","q","w","v","xmlns","elementName","_elementName","elementProxy","attrsString","attrsStart","cachedAttrs","getAttrs","nsUri","nsUriPrefix","nsName","defaultAlias","attrList","l","hasNewMatrix","newalias","value","alias","attrs","seenAttrs","skipAttr","parseAttr","charCodeAt","substring","substr","push","getParseContext","splitsRe","line","column","startOfLine","endOfLine","match","data","exec","index","create","trim","isNaN","pop","decode"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/node_modules/saxen/dist/index.esm.js"],"sourcesContent":["var fromCharCode = String.fromCharCode;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\n\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n};\n\n// map UPPERCASE variants of supported special chars\nObject.keys(ENTITY_MAPPING).forEach(function(k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\n\n\nfunction replaceEntities(_, d, x, z) {\n\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  }\n\n  // decimal encoded char\n  if (d) {\n    return fromCharCode(d);\n  }\n\n  // hex encoded char\n  return fromCharCode(parseInt(x, 16));\n}\n\n\n/**\n * A basic entity decoder that can decode a minimal\n * sub-set of reserved names (&amp;) as well as\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\n *\n * @param {string} str\n *\n * @return {string} decoded string\n */\nfunction decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n\n  return s;\n}\n\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\nvar XSI_PREFIX = 'xsi';\nvar XSI_TYPE = 'xsi:type';\n\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\n\nfunction error(msg) {\n  return new Error(msg);\n}\n\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\n\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\n\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {}, key;\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n  return clone;\n}\n\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\n\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n      uri,\n      prefix;\n\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n\n  return nsMatrix;\n}\n\nfunction noopGetContext() {\n  return { 'line': 0, 'column': 0 };\n}\n\nfunction throwFunc(err) {\n  throw err;\n}\n\n/**\n * Creates a new parser with the given options.\n *\n * @constructor\n *\n * @param  {!Object<string, ?>=} options\n */\nfunction Parser(options) {\n\n  if (!this) {\n    return new Parser(options);\n  }\n\n  var proxy = options && options['proxy'];\n\n  var onText,\n      onOpenTag,\n      onCloseTag,\n      onCDATA,\n      onError = throwFunc,\n      onWarning,\n      onComment,\n      onQuestion,\n      onAttention;\n\n  var getContext = noopGetContext;\n\n  /**\n   * Do we need to parse the current elements attributes for namespaces?\n   *\n   * @type {boolean}\n   */\n  var maybeNS = false;\n\n  /**\n   * Do we process namespaces at all?\n   *\n   * @type {boolean}\n   */\n  var isNamespace = false;\n\n  /**\n   * The caught error returned on parse end\n   *\n   * @type {Error}\n   */\n  var returnError = null;\n\n  /**\n   * Should we stop parsing?\n   *\n   * @type {boolean}\n   */\n  var parseStop = false;\n\n  /**\n   * A map of { uri: prefix } used by the parser.\n   *\n   * This map will ensure we can normalize prefixes during processing;\n   * for each uri, only one prefix will be exposed to the handlers.\n   *\n   * @type {!Object<string, string>}}\n   */\n  var nsUriToPrefix;\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    returnError = err;\n\n    onError(err, getContext);\n  }\n\n  /**\n   * Handle parse error.\n   *\n   * @param  {string|Error} err\n   */\n  function handleWarning(err) {\n\n    if (!onWarning) {\n      return;\n    }\n\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n\n    onWarning(err, getContext);\n  }\n\n  /**\n   * Register parse listener.\n   *\n   * @param  {string}   name\n   * @param  {Function} cb\n   *\n   * @return {Parser}\n   */\n  this['on'] = function(name, cb) {\n\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n\n    switch (name) {\n    case 'openTag': onOpenTag = cb; break;\n    case 'text': onText = cb; break;\n    case 'closeTag': onCloseTag = cb; break;\n    case 'error': onError = cb; break;\n    case 'warn': onWarning = cb; break;\n    case 'cdata': onCDATA = cb; break;\n    case 'attention': onAttention = cb; break; // <!XXXXX zzzz=\"eeee\">\n    case 'question': onQuestion = cb; break; // <? ....  ?>\n    case 'comment': onComment = cb; break;\n    default:\n      throw error('unsupported event: ' + name);\n    }\n\n    return this;\n  };\n\n  /**\n   * Set the namespace to prefix mapping.\n   *\n   * @example\n   *\n   * parser.ns({\n   *   'http://foo': 'foo',\n   *   'http://bar': 'bar'\n   * });\n   *\n   * @param  {!Object<string, string>} nsMap\n   *\n   * @return {Parser}\n   */\n  this['ns'] = function(nsMap) {\n\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n\n    var _nsUriToPrefix = {}, k;\n\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    }\n\n    // FORCE default mapping for schema instance\n    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;\n\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n\n    return this;\n  };\n\n  /**\n   * Parse xml string.\n   *\n   * @param  {string} xml\n   *\n   * @return {Error} returnError, if not thrown\n   */\n  this['parse'] = function(xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n\n    returnError = null;\n\n    parse(xml);\n\n    getContext = noopGetContext;\n    parseStop = false;\n\n    return returnError;\n  };\n\n  /**\n   * Stop parsing.\n   */\n  this['stop'] = function() {\n    parseStop = true;\n  };\n\n  /**\n   * Parse string, invoking configured listeners on element.\n   *\n   * @param  {string} xml\n   */\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n        _nsMatrix,\n        nodeStack = [],\n        anonymousNsCount = 0,\n        tagStart = false,\n        tagEnd = false,\n        i = 0, j = 0,\n        x, y, q, w, v,\n        xmlns,\n        elementName,\n        _elementName,\n        elementProxy\n        ;\n\n    var attrsString = '',\n        attrsStart = 0,\n        cachedAttrs // false = parsed with errors, null = needs parsing\n        ;\n\n    /**\n     * Parse attributes on demand and returns the parsed attributes.\n     *\n     * Return semantics: (1) `false` on attribute parse error,\n     * (2) object hash on extracted attrs.\n     *\n     * @return {boolean|Object}\n     */\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n\n      var nsUri,\n          nsUriPrefix,\n          nsName,\n          defaultAlias = isNamespace && nsMatrix['xmlns'],\n          attrList = isNamespace && maybeNS ? [] : null,\n          i = attrsStart,\n          s = attrsString,\n          l = s.length,\n          hasNewMatrix,\n          newalias,\n          value,\n          alias,\n          name,\n          attrs = {},\n          seenAttrs = {},\n          skipAttr,\n          w,\n          j;\n\n      parseAttr:\n      for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n\n        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        }\n\n        // wait for non whitespace character\n        if (w < 65 || w > 122 || (w > 90 && w < 97)) {\n          if (w !== 95 && w !== 58) { // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        }\n\n        // parse attribute name\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n\n          if (\n            w > 96 && w < 123 ||\n            w > 64 && w < 91 ||\n            w > 47 && w < 59 ||\n            w === 46 || // '.'\n            w === 45 || // '-'\n            w === 95 // '_'\n          ) {\n            continue;\n          }\n\n          // unexpected whitespace\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n\n            continue parseAttr;\n          }\n\n          // expected \"=\"\n          if (w === 61) { // \"=\" == 61\n            break;\n          }\n\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n\n        name = s.substring(i, j);\n\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n\n        w = s.charCodeAt(j + 1);\n\n        if (w === 34) { // '\"'\n          j = s.indexOf('\"', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else if (w === 39) { // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true;\n\n          // skip to next space\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n              break;\n            }\n          }\n\n        }\n\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n\n          j = l;\n          skipAttr = true;\n        }\n\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n\n        i = j;\n\n        // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\n            break;\n          }\n\n          // FIRST ILLEGAL CHAR\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        }\n\n        // advance cursor to next attribute\n        i = j + 1;\n\n        if (skipAttr) {\n          continue parseAttr;\n        }\n\n        // check attribute re-declaration\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n\n        seenAttrs[name] = true;\n\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // try to extract namespace information\n        if (maybeNS) {\n          newalias = (\n            name === 'xmlns'\n              ? 'xmlns'\n              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')\n                ? name.substr(6)\n                : null\n          );\n\n          // handle xmlns(:alias) assignment\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n\n            alias = nsUriToPrefix[nsUri];\n\n            if (!alias) {\n\n              // no prefix defined or prefix collision\n              if (\n                (newalias === 'xmlns') ||\n                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)\n              ) {\n\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + (anonymousNsCount++);\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n\n              nsUriToPrefix[nsUri] = alias;\n            }\n\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n\n              nsMatrix[newalias] = alias;\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n\n              nsMatrix[nsUriPrefix] = nsUri;\n            }\n\n            // expose xmlns(:asd)=\"...\" in attributes\n            attrs[name] = value;\n            continue;\n          }\n\n          // collect attributes until all namespace\n          // declarations are processed\n          attrList.push(name, value);\n          continue;\n\n        } /** end if (maybeNs) */\n\n        // handle attributes on element without\n        // namespace declarations\n        w = name.indexOf(':');\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // normalize ns attribute name\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n\n        name = defaultAlias === nsName\n          ? name.substr(w + 1)\n          : nsName + name.substr(w);\n\n        // end: normalize ns attribute name\n\n        // normalize xsi:type ns attribute value\n        if (name === XSI_TYPE) {\n          w = value.indexOf(':');\n\n          if (w !== -1) {\n            nsName = value.substring(0, w);\n\n            // handle default prefixes, i.e. xs:String gracefully\n            nsName = nsMatrix[nsName] || nsName;\n            value = nsName + value.substring(w);\n          } else {\n            value = defaultAlias + ':' + value;\n          }\n        }\n\n        // end: normalize xsi:type ns attribute value\n\n        attrs[name] = value;\n      }\n\n\n      // handle deferred, possibly namespaced attributes\n      if (maybeNS) {\n\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n\n          name = attrList[i++];\n          value = attrList[i];\n\n          w = name.indexOf(':');\n\n          if (w !== -1) {\n\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n\n            name = defaultAlias === nsName\n              ? name.substr(w + 1)\n              : nsName + name.substr(w);\n\n            // end: normalize ns attribute name\n\n            // normalize xsi:type ns attribute value\n            if (name === XSI_TYPE) {\n              w = value.indexOf(':');\n\n              if (w !== -1) {\n                nsName = value.substring(0, w);\n\n                // handle default prefixes, i.e. xs:String gracefully\n                nsName = nsMatrix[nsName] || nsName;\n                value = nsName + value.substring(w);\n              } else {\n                value = defaultAlias + ':' + value;\n              }\n            }\n\n            // end: normalize xsi:type ns attribute value\n          }\n\n          attrs[name] = value;\n        }\n\n        // end: normalize captured attributes\n      }\n\n      return cachedAttrs = attrs;\n    }\n\n    /**\n     * Extract the parse context { line, column, part }\n     * from the current parser position.\n     *\n     * @return {Object} parse context\n     */\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n\n      while (i >= startOfLine) {\n\n        match = splitsRe.exec(xml);\n\n        if (!match) {\n          break;\n        }\n\n        // end of line = (break idx + break chars)\n        endOfLine = match[0].length + match.index;\n\n        if (endOfLine > i) {\n          break;\n        }\n\n        // advance to next line\n        line += 1;\n\n        startOfLine = endOfLine;\n      }\n\n      // EOF errors\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else\n\n      // start errors\n      if (j === 0) {\n        data = xml.substring(j, i);\n      }\n\n      // other errors\n      else {\n        column = i - startOfLine;\n        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));\n      }\n\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n\n    getContext = getParseContext;\n\n\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function() {\n          return elementName;\n        }),\n        'originalName': getter(function() {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function() {\n          return nsMatrix;\n        })\n      });\n    }\n\n    // actual parse logic\n    while (j !== -1) {\n\n      if (xml.charCodeAt(j) === 60) { // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      }\n\n      // parse end\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n\n        return;\n      }\n\n      // parse text\n      if (j !== i) {\n\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n\n      w = xml.charCodeAt(i+1);\n\n      // parse comments + CDATA\n      if (w === 33) { // \"!\"\n        q = xml.charCodeAt(i+2);\n\n        // CDATA section\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n\n        // comment\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n\n\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n\n          j += 3;\n          continue;\n        }\n      }\n\n      // parse question <? ... ?>\n      if (w === 63) { // \"?\"\n        j = xml.indexOf('?>', i);\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 2;\n        continue;\n      }\n\n      // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n      for (x = i + 1; ; x++) {\n        v = xml.charCodeAt(x);\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        }\n\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n        if (v === 34) { //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) { // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) { // '>'\n          j = x;\n          break;\n        }\n      }\n\n\n      // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n      if (w === 33) { // \"!\"\n\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        j += 1;\n        continue;\n      }\n\n      // don't process attributes;\n      // there are none\n      cachedAttrs = {};\n\n      // if (xml.charCodeAt(i+1) === 47) { // </...\n      if (w === 47) { // </...\n        tagStart = false;\n        tagEnd = true;\n\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        }\n\n        // verify open <-> close tag match\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        }\n\n        // verify chars in close tag\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n\n          if (w === 32 || (w > 8 && w < 14)) { // \\f\\n\\r\\t\\v space\n            continue;\n          }\n\n          return handleError('close tag');\n        }\n\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) { // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n\n          tagStart = true;\n          tagEnd = true;\n\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n\n          tagStart = true;\n          tagEnd = false;\n        }\n\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n\n          if (w === 32 || (w < 14 && w > 8)) { // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q);\n\n            // maybe there are attributes\n            cachedAttrs = null;\n            break;\n          }\n\n          return handleError('invalid nodeName');\n        }\n\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n\n      if (isNamespace) {\n\n        _nsMatrix = nsMatrix;\n\n        if (tagStart) {\n\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n\n          if (cachedAttrs === null) {\n\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {\n              attrsStart = q;\n              attrsString = x;\n\n              getAttrs();\n\n              maybeNS = false;\n            }\n          }\n        }\n\n        _elementName = elementName;\n\n        w = elementName.indexOf(':');\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)];\n\n          // prefix given; namespace must exist\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns'];\n\n          // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        }\n\n        // adjust namespace prefixs as configured\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n\n      }\n\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n      }\n\n      if (tagEnd) {\n\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n\n          if (parseStop) {\n            return;\n          }\n        }\n\n        // restore old namespace\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n\n      j += 1;\n    }\n  } /** end parse */\n\n}\n\nexport { Parser, decodeEntities as decode };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}