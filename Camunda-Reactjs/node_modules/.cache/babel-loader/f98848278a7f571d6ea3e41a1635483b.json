{"ast":null,"code":"import { assign, filter, find, isArray, isNumber, isObject, isUndefined, groupBy, forEach } from 'min-dash';\n/**\n * Get parent elements.\n *\n * @param {Array<djs.model.base>} elements\n *\n * @returns {Array<djs.model.Base>}\n */\n\nexport function getParents(elements) {\n  // find elements that are not children of any other elements\n  return filter(elements, function (element) {\n    return !find(elements, function (e) {\n      return e !== element && getParent(element, e);\n    });\n  });\n}\n\nfunction getParent(element, parent) {\n  if (!parent) {\n    return;\n  }\n\n  if (element === parent) {\n    return parent;\n  }\n\n  if (!element.parent) {\n    return;\n  }\n\n  return getParent(element.parent, parent);\n}\n/**\n * Adds an element to a collection and returns true if the\n * element was added.\n *\n * @param {Array<Object>} elements\n * @param {Object} e\n * @param {boolean} unique\n */\n\n\nexport function add(elements, e, unique) {\n  var canAdd = !unique || elements.indexOf(e) === -1;\n\n  if (canAdd) {\n    elements.push(e);\n  }\n\n  return canAdd;\n}\n/**\n * Iterate over each element in a collection, calling the iterator function `fn`\n * with (element, index, recursionDepth).\n *\n * Recurse into all elements that are returned by `fn`.\n *\n * @param  {Object|Array<Object>} elements\n * @param  {Function} fn iterator function called with (element, index, recursionDepth)\n * @param  {number} [depth] maximum recursion depth\n */\n\nexport function eachElement(elements, fn, depth) {\n  depth = depth || 0;\n\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n\n  forEach(elements, function (s, i) {\n    var filter = fn(s, i, depth);\n\n    if (isArray(filter) && filter.length) {\n      eachElement(filter, fn, depth + 1);\n    }\n  });\n}\n/**\n * Collects self + child elements up to a given depth from a list of elements.\n *\n * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from\n * @param  {boolean} unique whether to return a unique result set (no duplicates)\n * @param  {number} maxDepth the depth to search through or -1 for infinite\n *\n * @return {Array<djs.model.Base>} found elements\n */\n\nexport function selfAndChildren(elements, unique, maxDepth) {\n  var result = [],\n      processedChildren = [];\n  eachElement(elements, function (element, i, depth) {\n    add(result, element, unique);\n    var children = element.children; // max traversal depth not reached yet\n\n    if (maxDepth === -1 || depth < maxDepth) {\n      // children exist && children not yet processed\n      if (children && add(processedChildren, children, unique)) {\n        return children;\n      }\n    }\n  });\n  return result;\n}\n/**\n * Return self + direct children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\n\nexport function selfAndDirectChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, 1);\n}\n/**\n * Return self + ALL children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\n\nexport function selfAndAllChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, -1);\n}\n/**\n * Gets the the closure for all selected elements,\n * their enclosed children and connections.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {boolean} [isTopLevel=true]\n * @param {Object} [existingClosure]\n *\n * @return {Object} newClosure\n */\n\nexport function getClosure(elements, isTopLevel, closure) {\n  if (isUndefined(isTopLevel)) {\n    isTopLevel = true;\n  }\n\n  if (isObject(isTopLevel)) {\n    closure = isTopLevel;\n    isTopLevel = true;\n  }\n\n  closure = closure || {};\n  var allShapes = copyObject(closure.allShapes),\n      allConnections = copyObject(closure.allConnections),\n      enclosedElements = copyObject(closure.enclosedElements),\n      enclosedConnections = copyObject(closure.enclosedConnections);\n  var topLevel = copyObject(closure.topLevel, isTopLevel && groupBy(elements, function (e) {\n    return e.id;\n  }));\n\n  function handleConnection(c) {\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\n      topLevel[c.id] = [c];\n    } // not enclosed as a child, but maybe logically\n    // (connecting two moved elements?)\n\n\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\n    }\n\n    allConnections[c.id] = c;\n  }\n\n  function handleElement(element) {\n    enclosedElements[element.id] = element;\n\n    if (element.waypoints) {\n      // remember connection\n      enclosedConnections[element.id] = allConnections[element.id] = element;\n    } else {\n      // remember shape\n      allShapes[element.id] = element; // remember all connections\n\n      forEach(element.incoming, handleConnection);\n      forEach(element.outgoing, handleConnection); // recurse into children\n\n      return element.children;\n    }\n  }\n\n  eachElement(elements, handleElement);\n  return {\n    allShapes: allShapes,\n    allConnections: allConnections,\n    topLevel: topLevel,\n    enclosedConnections: enclosedConnections,\n    enclosedElements: enclosedElements\n  };\n}\n/**\n * Returns the surrounding bbox for all elements in\n * the array or the element primitive.\n *\n * @param {Array<djs.model.Shape>|djs.model.Shape} elements\n * @param {boolean} stopRecursion\n */\n\nexport function getBBox(elements, stopRecursion) {\n  stopRecursion = !!stopRecursion;\n\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n\n  var minX, minY, maxX, maxY;\n  forEach(elements, function (element) {\n    // If element is a connection the bbox must be computed first\n    var bbox = element;\n\n    if (element.waypoints && !stopRecursion) {\n      bbox = getBBox(element.waypoints, true);\n    }\n\n    var x = bbox.x,\n        y = bbox.y,\n        height = bbox.height || 0,\n        width = bbox.width || 0;\n\n    if (x < minX || minX === undefined) {\n      minX = x;\n    }\n\n    if (y < minY || minY === undefined) {\n      minY = y;\n    }\n\n    if (x + width > maxX || maxX === undefined) {\n      maxX = x + width;\n    }\n\n    if (y + height > maxY || maxY === undefined) {\n      maxY = y + height;\n    }\n  });\n  return {\n    x: minX,\n    y: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n}\n/**\n * Returns all elements that are enclosed from the bounding box.\n *\n *   * If bbox.(width|height) is not specified the method returns\n *     all elements with element.x/y > bbox.x/y\n *   * If only bbox.x or bbox.y is specified, method return all elements with\n *     e.x > bbox.x or e.y > bbox.y\n *\n * @param {Array<djs.model.Shape>} elements List of Elements to search through\n * @param {djs.model.Shape} bbox the enclosing bbox.\n *\n * @return {Array<djs.model.Shape>} enclosed elements\n */\n\nexport function getEnclosedElements(elements, bbox) {\n  var filteredElements = {};\n  forEach(elements, function (element) {\n    var e = element;\n\n    if (e.waypoints) {\n      e = getBBox(e);\n    }\n\n    if (!isNumber(bbox.y) && e.x > bbox.x) {\n      filteredElements[element.id] = element;\n    }\n\n    if (!isNumber(bbox.x) && e.y > bbox.y) {\n      filteredElements[element.id] = element;\n    }\n\n    if (e.x > bbox.x && e.y > bbox.y) {\n      if (isNumber(bbox.width) && isNumber(bbox.height) && e.width + e.x < bbox.width + bbox.x && e.height + e.y < bbox.height + bbox.y) {\n        filteredElements[element.id] = element;\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\n        filteredElements[element.id] = element;\n      }\n    }\n  });\n  return filteredElements;\n}\nexport function getType(element) {\n  if ('waypoints' in element) {\n    return 'connection';\n  }\n\n  if ('x' in element) {\n    return 'shape';\n  }\n\n  return 'root';\n}\nexport function isFrameElement(element) {\n  return !!(element && element.isFrame);\n} // helpers ///////////////////////////////\n\nfunction copyObject(src1, src2) {\n  return assign({}, src1 || {}, src2 || {});\n}","map":{"version":3,"names":["assign","filter","find","isArray","isNumber","isObject","isUndefined","groupBy","forEach","getParents","elements","element","e","getParent","parent","add","unique","canAdd","indexOf","push","eachElement","fn","depth","s","i","length","selfAndChildren","maxDepth","result","processedChildren","children","selfAndDirectChildren","allowDuplicates","selfAndAllChildren","getClosure","isTopLevel","closure","allShapes","copyObject","allConnections","enclosedElements","enclosedConnections","topLevel","id","handleConnection","c","source","target","handleElement","waypoints","incoming","outgoing","getBBox","stopRecursion","minX","minY","maxX","maxY","bbox","x","y","height","width","undefined","getEnclosedElements","filteredElements","getType","isFrameElement","isFrame","src1","src2"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/node_modules/diagram-js/lib/util/Elements.js"],"sourcesContent":["import {\n  assign,\n  filter,\n  find,\n  isArray,\n  isNumber,\n  isObject,\n  isUndefined,\n  groupBy,\n  forEach\n} from 'min-dash';\n\n\n/**\n * Get parent elements.\n *\n * @param {Array<djs.model.base>} elements\n *\n * @returns {Array<djs.model.Base>}\n */\nexport function getParents(elements) {\n\n  // find elements that are not children of any other elements\n  return filter(elements, function(element) {\n    return !find(elements, function(e) {\n      return e !== element && getParent(element, e);\n    });\n  });\n}\n\n\nfunction getParent(element, parent) {\n  if (!parent) {\n    return;\n  }\n\n  if (element === parent) {\n    return parent;\n  }\n\n  if (!element.parent) {\n    return;\n  }\n\n  return getParent(element.parent, parent);\n}\n\n\n/**\n * Adds an element to a collection and returns true if the\n * element was added.\n *\n * @param {Array<Object>} elements\n * @param {Object} e\n * @param {boolean} unique\n */\nexport function add(elements, e, unique) {\n  var canAdd = !unique || elements.indexOf(e) === -1;\n\n  if (canAdd) {\n    elements.push(e);\n  }\n\n  return canAdd;\n}\n\n\n/**\n * Iterate over each element in a collection, calling the iterator function `fn`\n * with (element, index, recursionDepth).\n *\n * Recurse into all elements that are returned by `fn`.\n *\n * @param  {Object|Array<Object>} elements\n * @param  {Function} fn iterator function called with (element, index, recursionDepth)\n * @param  {number} [depth] maximum recursion depth\n */\nexport function eachElement(elements, fn, depth) {\n\n  depth = depth || 0;\n\n  if (!isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  forEach(elements, function(s, i) {\n    var filter = fn(s, i, depth);\n\n    if (isArray(filter) && filter.length) {\n      eachElement(filter, fn, depth + 1);\n    }\n  });\n}\n\n\n/**\n * Collects self + child elements up to a given depth from a list of elements.\n *\n * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from\n * @param  {boolean} unique whether to return a unique result set (no duplicates)\n * @param  {number} maxDepth the depth to search through or -1 for infinite\n *\n * @return {Array<djs.model.Base>} found elements\n */\nexport function selfAndChildren(elements, unique, maxDepth) {\n  var result = [],\n      processedChildren = [];\n\n  eachElement(elements, function(element, i, depth) {\n    add(result, element, unique);\n\n    var children = element.children;\n\n    // max traversal depth not reached yet\n    if (maxDepth === -1 || depth < maxDepth) {\n\n      // children exist && children not yet processed\n      if (children && add(processedChildren, children, unique)) {\n        return children;\n      }\n    }\n  });\n\n  return result;\n}\n\n/**\n * Return self + direct children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nexport function selfAndDirectChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, 1);\n}\n\n\n/**\n * Return self + ALL children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nexport function selfAndAllChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, -1);\n}\n\n\n/**\n * Gets the the closure for all selected elements,\n * their enclosed children and connections.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {boolean} [isTopLevel=true]\n * @param {Object} [existingClosure]\n *\n * @return {Object} newClosure\n */\nexport function getClosure(elements, isTopLevel, closure) {\n\n  if (isUndefined(isTopLevel)) {\n    isTopLevel = true;\n  }\n\n  if (isObject(isTopLevel)) {\n    closure = isTopLevel;\n    isTopLevel = true;\n  }\n\n\n  closure = closure || {};\n\n  var allShapes = copyObject(closure.allShapes),\n      allConnections = copyObject(closure.allConnections),\n      enclosedElements = copyObject(closure.enclosedElements),\n      enclosedConnections = copyObject(closure.enclosedConnections);\n\n  var topLevel = copyObject(\n    closure.topLevel,\n    isTopLevel && groupBy(elements, function(e) { return e.id; })\n  );\n\n\n  function handleConnection(c) {\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\n      topLevel[c.id] = [ c ];\n    }\n\n    // not enclosed as a child, but maybe logically\n    // (connecting two moved elements?)\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\n    }\n\n    allConnections[c.id] = c;\n  }\n\n  function handleElement(element) {\n\n    enclosedElements[element.id] = element;\n\n    if (element.waypoints) {\n\n      // remember connection\n      enclosedConnections[element.id] = allConnections[element.id] = element;\n    } else {\n\n      // remember shape\n      allShapes[element.id] = element;\n\n      // remember all connections\n      forEach(element.incoming, handleConnection);\n\n      forEach(element.outgoing, handleConnection);\n\n      // recurse into children\n      return element.children;\n    }\n  }\n\n  eachElement(elements, handleElement);\n\n  return {\n    allShapes: allShapes,\n    allConnections: allConnections,\n    topLevel: topLevel,\n    enclosedConnections: enclosedConnections,\n    enclosedElements: enclosedElements\n  };\n}\n\n/**\n * Returns the surrounding bbox for all elements in\n * the array or the element primitive.\n *\n * @param {Array<djs.model.Shape>|djs.model.Shape} elements\n * @param {boolean} stopRecursion\n */\nexport function getBBox(elements, stopRecursion) {\n\n  stopRecursion = !!stopRecursion;\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n\n  var minX,\n      minY,\n      maxX,\n      maxY;\n\n  forEach(elements, function(element) {\n\n    // If element is a connection the bbox must be computed first\n    var bbox = element;\n    if (element.waypoints && !stopRecursion) {\n      bbox = getBBox(element.waypoints, true);\n    }\n\n    var x = bbox.x,\n        y = bbox.y,\n        height = bbox.height || 0,\n        width = bbox.width || 0;\n\n    if (x < minX || minX === undefined) {\n      minX = x;\n    }\n    if (y < minY || minY === undefined) {\n      minY = y;\n    }\n\n    if ((x + width) > maxX || maxX === undefined) {\n      maxX = x + width;\n    }\n    if ((y + height) > maxY || maxY === undefined) {\n      maxY = y + height;\n    }\n  });\n\n  return {\n    x: minX,\n    y: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n}\n\n\n/**\n * Returns all elements that are enclosed from the bounding box.\n *\n *   * If bbox.(width|height) is not specified the method returns\n *     all elements with element.x/y > bbox.x/y\n *   * If only bbox.x or bbox.y is specified, method return all elements with\n *     e.x > bbox.x or e.y > bbox.y\n *\n * @param {Array<djs.model.Shape>} elements List of Elements to search through\n * @param {djs.model.Shape} bbox the enclosing bbox.\n *\n * @return {Array<djs.model.Shape>} enclosed elements\n */\nexport function getEnclosedElements(elements, bbox) {\n\n  var filteredElements = {};\n\n  forEach(elements, function(element) {\n\n    var e = element;\n\n    if (e.waypoints) {\n      e = getBBox(e);\n    }\n\n    if (!isNumber(bbox.y) && (e.x > bbox.x)) {\n      filteredElements[element.id] = element;\n    }\n    if (!isNumber(bbox.x) && (e.y > bbox.y)) {\n      filteredElements[element.id] = element;\n    }\n    if (e.x > bbox.x && e.y > bbox.y) {\n      if (isNumber(bbox.width) && isNumber(bbox.height) &&\n          e.width + e.x < bbox.width + bbox.x &&\n          e.height + e.y < bbox.height + bbox.y) {\n\n        filteredElements[element.id] = element;\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\n        filteredElements[element.id] = element;\n      }\n    }\n  });\n\n  return filteredElements;\n}\n\n\nexport function getType(element) {\n\n  if ('waypoints' in element) {\n    return 'connection';\n  }\n\n  if ('x' in element) {\n    return 'shape';\n  }\n\n  return 'root';\n}\n\nexport function isFrameElement(element) {\n\n  return !!(element && element.isFrame);\n}\n\n// helpers ///////////////////////////////\n\nfunction copyObject(src1, src2) {\n  return assign({}, src1 || {}, src2 || {});\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}