{"ast":null,"code":"'use strict';\n/**\n * An empty collection stub. Use {@link RefsCollection.extend} to extend a\n * collection with ref semantics.\n *\n * @class RefsCollection\n */\n\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @memberof RefsCollection\n * @static\n *\n * @param  {Array<Object>} collection\n * @param  {Refs} refs instance\n * @param  {Object} property represented by the collection\n * @param  {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\n\nfunction extend(collection, refs, property, target) {\n  var inverseProperty = property.inverse;\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n\n  Object.defineProperty(collection, 'remove', {\n    value: function (element) {\n      var idx = this.indexOf(element);\n\n      if (idx !== -1) {\n        this.splice(idx, 1); // unset inverse\n\n        refs.unset(element, inverseProperty, target);\n      }\n\n      return element;\n    }\n  });\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n\n  Object.defineProperty(collection, 'contains', {\n    value: function (element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n\n  Object.defineProperty(collection, 'add', {\n    value: function (element, idx) {\n      var currentIdx = this.indexOf(element);\n\n      if (typeof idx === 'undefined') {\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        } // add to end of array, as no idx is specified\n\n\n        idx = this.length;\n      } // handle already in collection\n\n\n      if (currentIdx !== -1) {\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      } // add element at idx\n\n\n      this.splice(idx, 0, element);\n\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  }); // a simple marker, identifying this element\n  // as being a refs collection\n\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n  return collection;\n}\n\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nmodule.exports.extend = extend;\nmodule.exports.isExtended = isExtended;","map":{"version":3,"names":["extend","collection","refs","property","target","inverseProperty","inverse","Object","defineProperty","value","element","idx","indexOf","splice","unset","currentIdx","length","set","isExtended","__refs_collection","module","exports"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/node_modules/object-refs/lib/collection.js"],"sourcesContent":["'use strict';\n\n/**\n * An empty collection stub. Use {@link RefsCollection.extend} to extend a\n * collection with ref semantics.\n *\n * @class RefsCollection\n */\n\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @memberof RefsCollection\n * @static\n *\n * @param  {Array<Object>} collection\n * @param  {Refs} refs instance\n * @param  {Object} property represented by the collection\n * @param  {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function(element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function(element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function(element, idx) {\n\n      var currentIdx = this.indexOf(element);\n\n      if (typeof idx === 'undefined') {\n\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n\n  return collection;\n}\n\n\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nmodule.exports.extend = extend;\n\nmodule.exports.isExtended = isExtended;"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,MAAT,CAAgBC,UAAhB,EAA4BC,IAA5B,EAAkCC,QAAlC,EAA4CC,MAA5C,EAAoD;EAElD,IAAIC,eAAe,GAAGF,QAAQ,CAACG,OAA/B;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;;EACEC,MAAM,CAACC,cAAP,CAAsBP,UAAtB,EAAkC,QAAlC,EAA4C;IAC1CQ,KAAK,EAAE,UAASC,OAAT,EAAkB;MACvB,IAAIC,GAAG,GAAG,KAAKC,OAAL,CAAaF,OAAb,CAAV;;MACA,IAAIC,GAAG,KAAK,CAAC,CAAb,EAAgB;QACd,KAAKE,MAAL,CAAYF,GAAZ,EAAiB,CAAjB,EADc,CAGd;;QACAT,IAAI,CAACY,KAAL,CAAWJ,OAAX,EAAoBL,eAApB,EAAqCD,MAArC;MACD;;MAED,OAAOM,OAAP;IACD;EAXyC,CAA5C;EAcA;AACF;AACA;AACA;AACA;AACA;AACA;;EACEH,MAAM,CAACC,cAAP,CAAsBP,UAAtB,EAAkC,UAAlC,EAA8C;IAC5CQ,KAAK,EAAE,UAASC,OAAT,EAAkB;MACvB,OAAO,KAAKE,OAAL,CAAaF,OAAb,MAA0B,CAAC,CAAlC;IACD;EAH2C,CAA9C;EAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACEH,MAAM,CAACC,cAAP,CAAsBP,UAAtB,EAAkC,KAAlC,EAAyC;IACvCQ,KAAK,EAAE,UAASC,OAAT,EAAkBC,GAAlB,EAAuB;MAE5B,IAAII,UAAU,GAAG,KAAKH,OAAL,CAAaF,OAAb,CAAjB;;MAEA,IAAI,OAAOC,GAAP,KAAe,WAAnB,EAAgC;QAE9B,IAAII,UAAU,KAAK,CAAC,CAApB,EAAuB;UACrB;UACA;QACD,CAL6B,CAO9B;;;QACAJ,GAAG,GAAG,KAAKK,MAAX;MACD,CAb2B,CAe5B;;;MACA,IAAID,UAAU,KAAK,CAAC,CAApB,EAAuB;QAErB;QACA,KAAKF,MAAL,CAAYE,UAAZ,EAAwB,CAAxB;MACD,CApB2B,CAsB5B;;;MACA,KAAKF,MAAL,CAAYF,GAAZ,EAAiB,CAAjB,EAAoBD,OAApB;;MAEA,IAAIK,UAAU,KAAK,CAAC,CAApB,EAAuB;QACrB;QACA;QACAb,IAAI,CAACe,GAAL,CAASP,OAAT,EAAkBL,eAAlB,EAAmCD,MAAnC;MACD;IACF;EA/BsC,CAAzC,EA/CkD,CAiFlD;EACA;;EACAG,MAAM,CAACC,cAAP,CAAsBP,UAAtB,EAAkC,mBAAlC,EAAuD;IACrDQ,KAAK,EAAE;EAD8C,CAAvD;EAIA,OAAOR,UAAP;AACD;;AAGD,SAASiB,UAAT,CAAoBjB,UAApB,EAAgC;EAC9B,OAAOA,UAAU,CAACkB,iBAAX,KAAiC,IAAxC;AACD;;AAEDC,MAAM,CAACC,OAAP,CAAerB,MAAf,GAAwBA,MAAxB;AAEAoB,MAAM,CAACC,OAAP,CAAeH,UAAf,GAA4BA,UAA5B"},"metadata":{},"sourceType":"script"}