{"ast":null,"code":"import { forEach, assign, find, filter, has, isString } from 'min-dash';\nimport { Parser } from 'saxen';\nimport { coerceType, parseNameNS, isSimpleType, Moddle } from 'moddle';\n\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\n\nvar DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\nvar XSI_TYPE = 'xsi:type';\n\nfunction serializeFormat(element) {\n  return element.xml && element.xml.serialize;\n}\n\nfunction serializeAsType(element) {\n  return serializeFormat(element) === XSI_TYPE;\n}\n\nfunction serializeAsProperty(element) {\n  return serializeFormat(element) === 'property';\n}\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction aliasToName(aliasNs, pkg) {\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\nfunction prefixedToName(nameNs, pkg) {\n  var name = nameNs.name,\n      localName = nameNs.localName;\n  var typePrefix = pkg.xml && pkg.xml.typePrefix;\n\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\n\nfunction normalizeXsiTypeName(name, model) {\n  var nameNs = parseNameNS(name);\n  var pkg = model.getPackage(nameNs.prefix);\n  return prefixedToName(nameNs, pkg);\n}\n\nfunction error(message) {\n  return new Error(message);\n}\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\n\n\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\n\n\nfunction Context(options) {\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n  assign(this, options);\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n\n  this.addReference = function (reference) {\n    this.references.push(reference);\n  };\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n\n\n  this.addElement = function (element) {\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n    var descriptor = getModdleDescriptor(element);\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n\n\n  this.addWarning = function (warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function () {};\n\nBaseHandler.prototype.handleText = function () {};\n\nBaseHandler.prototype.handleNode = function () {};\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\n\n\nfunction NoopHandler() {}\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function () {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function (text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function (node) {\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function () {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function (node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function () {\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n  value = coerceType(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function (node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n/**\n * @class Reader.ElementHandler\n *\n */\n\n\nfunction ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\n\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function (reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleText = function (text) {\n  var element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n\n  BodyHandler.prototype.handleText.call(this, text);\n};\n\nElementHandler.prototype.handleEnd = function () {\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\n\n\nElementHandler.prototype.createElement = function (node) {\n  var attributes = node.attributes,\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({}),\n      model = this.model,\n      propNameNs;\n  forEach(attributes, function (value, name) {\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n        forEach(values, function (v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else if (name !== 'xmlns') {\n        propNameNs = parseNameNS(name, descriptor.ns.prefix); // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n\n        if (model.getPackage(propNameNs.prefix)) {\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n\n      instance.set(name, value);\n    }\n  });\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function (node) {\n  var name = node.name;\n  var nameNs = parseNameNS(name);\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName],\n      elementTypeName,\n      elementType; // search for properties by name first\n\n  if (property && !property.isAttr) {\n    if (serializeAsType(property)) {\n      elementTypeName = node.attributes[XSI_TYPE]; // xsi type is optional, if it does not exists the\n      // default type is assumed\n\n      if (elementTypeName) {\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\"\n        elementTypeName = normalizeXsiTypeName(elementTypeName, model);\n        elementType = model.getType(elementTypeName);\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    } // search for properties by name first\n\n\n    return property;\n  }\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    elementTypeName = aliasToName(nameNs, pkg);\n    elementType = model.getType(elementTypeName); // search for collection members later\n\n    property = find(descriptor.properties, function (p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function (p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function () {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function (propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function (propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function (type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\n\n\nElementHandler.prototype.handleChild = function (node) {\n  var propertyDesc, type, element, childHandler;\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element; // child handles may decide to skip elements\n  // by not returning anything\n\n  if (newElement !== undefined) {\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n      this.context.addReference(newElement);\n    } else {\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\n\n\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\n\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\nRootElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n      nameNs = parseNameNS(name),\n      model = this.model,\n      type = this.type,\n      pkg = model.getPackage(nameNs.prefix),\n      typeName = pkg && aliasToName(nameNs, pkg) || name; // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n\n  return ElementHandler.prototype.createElement.call(this, node);\n};\n\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n      ns = parseNameNS(name),\n      prefix = ns.prefix,\n      uri = node.ns[prefix + '$uri'],\n      attributes = node.attributes;\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function (node) {\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement); // establish child -> parent relationship\n\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleEnd = function () {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\n\n\nfunction Reader(options) {\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  assign(this, {\n    lax: false\n  }, options);\n}\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML result.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\n\n\nReader.prototype.fromXML = function (xml, options, done) {\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n  var context = new Context(assign({}, options, {\n    rootHandler: rootHandler\n  })),\n      parser = new Parser({\n    proxy: true\n  }),\n      stack = createStack();\n  rootHandler.context = context; // push root handler\n\n  stack.push(rootHandler);\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n\n  function handleError(err, getContext, lax) {\n    var ctx = getContext();\n    var line = ctx.line,\n        column = ctx.column,\n        data = ctx.data; // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n\n    var message = 'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' + 'line: ' + line + '\\n\\t' + 'column: ' + column + '\\n\\t' + 'nested error: ' + err.message;\n\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n\n  function handleWarning(err, getContext) {\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n  /**\n   * Resolve collected references on parse end.\n   */\n\n\n  function resolveReferences() {\n    var elementsById = context.elementsById;\n    var references = context.references;\n    var i, r;\n\n    for (i = 0; r = references[i]; i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r); // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n  var UTF_8_PATTERN = /^utf-8$/i;\n\n  function handleQuestion(question) {\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n\n    context.addWarning({\n      message: 'unsupported document encoding <' + encoding + '>, ' + 'falling back to UTF-8'\n    });\n  }\n\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n\n  function handleCData(text, getContext) {\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n\n  function handleText(text, getContext) {\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n    if (!text.trim()) {\n      return;\n    }\n\n    handleCData(text, getContext);\n  }\n\n  var uriMap = model.getPackages().reduce(function (uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n    return uriMap;\n  }, {\n    'http://www.w3.org/XML/1998/namespace': 'xml' // add default xml ns\n\n  });\n  parser.ns(uriMap).on('openTag', function (obj, decodeStr, selfClosing, getContext) {\n    // gracefully handle unparsable attributes (attrs=false)\n    var attrs = obj.attrs || {};\n    var decodedAttrs = Object.keys(attrs).reduce(function (d, key) {\n      var value = decodeStr(attrs[key]);\n      d[key] = value;\n      return d;\n    }, {});\n    var node = {\n      name: obj.name,\n      originalName: obj.originalName,\n      attributes: decodedAttrs,\n      ns: obj.ns\n    };\n    handleOpen(node, getContext);\n  }).on('question', handleQuestion).on('closeTag', handleClose).on('cdata', handleCData).on('text', function (text, decodeEntities, getContext) {\n    handleText(decodeEntities(text), getContext);\n  }).on('error', handleError).on('warn', handleWarning); // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n\n  return new Promise(function (resolve, reject) {\n    var err;\n\n    try {\n      parser.parse(xml);\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n\n    var rootElement = rootHandler.element;\n\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n\n    if (err) {\n      err.warnings = warnings;\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\n\nReader.prototype.handler = function (name) {\n  return new RootElementHandler(this.model, name);\n}; // helpers //////////////////////////\n\n\nfunction createStack() {\n  var stack = [];\n  Object.defineProperty(stack, 'peek', {\n    value: function () {\n      return this[this.length - 1];\n    }\n  });\n  return stack;\n}\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\n\nfunction Namespaces(parent) {\n  var prefixMap = {};\n  var uriMap = {};\n  var used = {};\n  var wellknown = [];\n  var custom = []; // API\n\n  this.byUri = function (uri) {\n    return uriMap[uri] || parent && parent.byUri(uri);\n  };\n\n  this.add = function (ns, isWellknown) {\n    uriMap[ns.uri] = ns;\n\n    if (isWellknown) {\n      wellknown.push(ns);\n    } else {\n      custom.push(ns);\n    }\n\n    this.mapPrefix(ns.prefix, ns.uri);\n  };\n\n  this.uriByPrefix = function (prefix) {\n    return prefixMap[prefix || 'xmlns'];\n  };\n\n  this.mapPrefix = function (prefix, uri) {\n    prefixMap[prefix || 'xmlns'] = uri;\n  };\n\n  this.getNSKey = function (ns) {\n    return ns.prefix !== undefined ? ns.uri + '|' + ns.prefix : ns.uri;\n  };\n\n  this.logUsed = function (ns) {\n    var uri = ns.uri;\n    var nsKey = this.getNSKey(ns);\n    used[nsKey] = this.byUri(uri); // Inform parent recursively about the usage of this NS\n\n    if (parent) {\n      parent.logUsed(ns);\n    }\n  };\n\n  this.getUsed = function (ns) {\n    function isUsed(ns) {\n      var nsKey = self.getNSKey(ns);\n      return used[nsKey];\n    }\n\n    var self = this;\n    var allNs = [].concat(wellknown, custom);\n    return allNs.filter(isUsed);\n  };\n}\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n  return namespaces.getUsed().filter(function (ns) {\n    // do not serialize built in <xml> namespace\n    return ns.prefix !== 'xml';\n  }).map(function (ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return {\n      name: name,\n      value: ns.uri\n    };\n  });\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({\n      localName: descriptor.ns.localName\n    }, ns);\n  } else {\n    return assign({\n      localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)\n    }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return assign({\n    localName: descriptor.ns.localName\n  }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n  return filter(descriptor.properties, function (p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    } // do not serialize defaults\n\n\n    if (!has(element, name)) {\n      return false;\n    }\n\n    var value = element[name]; // do not serialize default equals\n\n    if (value === p.default) {\n      return false;\n    } // do not serialize null properties\n\n\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\n\nfunction escape(str, charPattern, replaceMap) {\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n  return str.replace(charPattern, function (s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\n\n\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\n\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\n\nfunction filterAttributes(props) {\n  return filter(props, function (p) {\n    return p.isAttr;\n  });\n}\n\nfunction filterContained(props) {\n  return filter(props, function (p) {\n    return !p.isAttr;\n  });\n}\n\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\n\nReferenceSerializer.prototype.build = function (element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {\n  writer.append(this.escape ? escapeBody(this.value) : this.value);\n};\n\nBodySerializer.prototype.build = function (prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>');\n  this.serializeValue(writer);\n  writer.append('</' + this.tagName + '>').appendNewLine();\n};\n\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\n\nElementSerializer.prototype.build = function (element) {\n  this.element = element;\n  var elementDescriptor = element.$descriptor,\n      propertyDescriptor = this.propertyDescriptor;\n  var otherAttrs, properties;\n  var isGeneric = elementDescriptor.isGeneric;\n\n  if (isGeneric) {\n    otherAttrs = this.parseGeneric(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  } // compute tag name\n\n\n  this.tagName = this.addTagName(this.ns);\n\n  if (!isGeneric) {\n    properties = getSerializableProperties(element);\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n\n  this.parseGenericAttributes(element, otherAttrs);\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === this.ns.uri;\n};\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\n\n\nElementSerializer.prototype.nsAttributeName = function (element) {\n  var ns;\n\n  if (isString(element)) {\n    ns = parseNameNS(element);\n  } else {\n    ns = element.ns;\n  } // return just local name for inherited attributes\n\n\n  if (element.inherited) {\n    return {\n      localName: ns.localName\n    };\n  } // parse + log effective ns\n\n\n  var effectiveNs = this.logNamespaceUsed(ns); // LOG ACTUAL namespace use\n\n  this.getNamespaces().logUsed(effectiveNs); // strip prefix if same namespace like parent\n\n  if (this.isLocalNs(effectiveNs)) {\n    return {\n      localName: ns.localName\n    };\n  } else {\n    return assign({\n      localName: ns.localName\n    }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGeneric = function (element) {\n  var self = this,\n      body = this.body;\n  var attributes = [];\n  forEach(element, function (val, key) {\n    var nonNsAttr;\n\n    if (key === '$body') {\n      body.push(new BodySerializer().build({\n        type: 'String'\n      }, val));\n    } else if (key === '$children') {\n      forEach(val, function (child) {\n        body.push(new ElementSerializer(self).build(child));\n      });\n    } else if (key.indexOf('$') !== 0) {\n      nonNsAttr = self.parseNsAttribute(element, key, val);\n\n      if (nonNsAttr) {\n        attributes.push({\n          name: key,\n          value: val\n        });\n      }\n    }\n  });\n  return attributes;\n};\n\nElementSerializer.prototype.parseNsAttribute = function (element, name, value) {\n  var model = element.$model;\n  var nameNs = parseNameNS(name);\n  var ns; // parse xmlns:foo=\"http://foo.bar\"\n\n  if (nameNs.prefix === 'xmlns') {\n    ns = {\n      prefix: nameNs.localName,\n      uri: value\n    };\n  } // parse xmlns=\"http://foo.bar\"\n\n\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = {\n      uri: value\n    };\n  }\n\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  if (model && model.getPackage(value)) {\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\n\n\nElementSerializer.prototype.parseNsAttributes = function (element, attrs) {\n  var self = this;\n  var genericAttrs = element.$attrs;\n  var attributes = []; // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n\n  forEach(genericAttrs, function (value, name) {\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {\n  var self = this;\n  forEach(attributes, function (attr) {\n    // do not serialize xsi:type attribute\n    // it is set manually based on the actual implementation type\n    if (attr.name === XSI_TYPE) {\n      return;\n    }\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      console.warn('missing namespace information for ', attr.name, '=', attr.value, 'on', element, e);\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function (properties) {\n  var self = this,\n      body = this.body,\n      element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    if (!isMany) {\n      value = [value];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if (isSimpleType(p.type)) {\n      forEach(value, function (v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      forEach(value, function (v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n      // allow serialization via type\n      // rather than element name\n      var asType = serializeAsType(p),\n          asProperty = serializeAsProperty(p);\n      forEach(value, function (v) {\n        var serializer;\n\n        if (asType) {\n          serializer = new TypeSerializer(self, p);\n        } else if (asProperty) {\n          serializer = new ElementSerializer(self, p);\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function (local) {\n  var namespaces = this.namespaces,\n      parent = this.parent,\n      parentNamespaces;\n\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function (ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n  var nsUri = ns.uri,\n      nsPrefix = ns.prefix;\n  var existing = namespaces.byUri(nsUri);\n\n  if (!existing || local) {\n    namespaces.add(ns, wellknown);\n  }\n\n  namespaces.mapPrefix(nsPrefix, nsUri);\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function (ns, local) {\n  var element = this.element,\n      model = element.$model,\n      namespaces = this.getNamespaces(local); // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n      uri = ns.uri,\n      newPrefix,\n      idx,\n      wellknownUri; // handle anonymous namespaces (elementForm=unqualified), cf. #23\n\n  if (!prefix && !uri) {\n    return {\n      localName: ns.localName\n    };\n  }\n\n  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n\n  ns = namespaces.byUri(uri);\n\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1; // find a prefix that is not mapped yet\n\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n\n    ns = this.logNamespace({\n      prefix: newPrefix,\n      uri: uri\n    }, wellknownUri === uri);\n  }\n\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function (properties) {\n  var self = this,\n      element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        forEach(value, function (v) {\n          values.push(v.id);\n        }); // IDREFS is a whitespace-separated list of references.\n\n        value = values.join(' ');\n      }\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addTagName = function (nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n  this.getNamespaces().logUsed(actualNs);\n  return nsName(nsTagName);\n};\n\nElementSerializer.prototype.addAttribute = function (name, value) {\n  var attrs = this.attrs;\n\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  attrs.push({\n    name: name,\n    value: value\n  });\n};\n\nElementSerializer.prototype.serializeAttributes = function (writer) {\n  var attrs = this.attrs,\n      namespaces = this.namespaces;\n\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n\n  forEach(attrs, function (a) {\n    writer.append(' ').append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function (writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n  writer.appendIndent().append('<' + this.tagName);\n  this.serializeAttributes(writer);\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n    if (indent) {\n      writer.appendNewLine().indent();\n    }\n\n    forEach(this.body, function (b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer.unindent().appendIndent();\n    }\n\n    writer.append('</' + this.tagName + '>');\n  }\n\n  writer.appendNewLine();\n};\n/**\n * A serializer for types that handles serialization of data types\n */\n\n\nfunction TypeSerializer(parent, propertyDescriptor) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.parseNsAttributes = function (element) {\n  // extracted attributes\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);\n  var descriptor = element.$descriptor; // only serialize xsi:type if necessary\n\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs); // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = pkg.xml && pkg.xml.typePrefix || '';\n  this.addAttribute(this.nsAttributeName(XSI_TYPE), (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName);\n  return attributes;\n};\n\nTypeSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function (str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n  var indent = [''];\n\n  this.append = function (str) {\n    out.write(str);\n    return this;\n  };\n\n  this.appendNewLine = function () {\n    if (format) {\n      out.write('\\n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function () {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function () {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function () {\n    indent.pop();\n    return this;\n  };\n}\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\n\n\nfunction Writer(options) {\n  options = assign({\n    format: false,\n    preamble: true\n  }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}\n\nexport { Reader, Writer };","map":{"version":3,"names":["forEach","assign","find","filter","has","isString","Parser","coerceType","parseNameNS","isSimpleType","Moddle","hasLowerCaseAlias","pkg","xml","tagAlias","DEFAULT_NS_MAP","XSI_TYPE","serializeFormat","element","serialize","serializeAsType","serializeAsProperty","capitalize","str","charAt","toUpperCase","slice","aliasToName","aliasNs","name","prefix","localName","prefixedToName","nameNs","typePrefix","indexOf","length","normalizeXsiTypeName","model","getPackage","error","message","Error","getModdleDescriptor","$descriptor","Context","options","elementsById","references","warnings","addReference","reference","push","addElement","descriptor","idProperty","id","get","test","addWarning","warning","BaseHandler","prototype","handleEnd","handleText","handleNode","NoopHandler","Object","create","BodyHandler","text","body","ReferenceHandler","property","context","node","createReference","ns","ValueHandler","propertyDesc","value","type","isMany","set","BaseElementHandler","parser","createElement","handleChild","ElementHandler","typeName","getType","bodyProperty","call","undefined","attributes","Type","instance","propNameNs","prop","propertiesByName","values","isReference","split","v","getPropertyForNode","propertyName","elementTypeName","elementType","isAttr","effectiveType","properties","p","isVirtual","isAttribute","hasType","toString","valueHandler","referenceHandler","handler","GenericElementHandler","childHandler","newElement","$parent","RootElementHandler","originalName","uri","createAny","children","$children","$body","Reader","lax","fromXML","done","rootHandler","proxy","stack","createStack","handleError","err","getContext","ctx","line","column","data","handleWarning","resolveReferences","i","r","collection","idx","splice","handleClose","pop","PREAMBLE_START_PATTERN","ENCODING_PATTERN","UTF_8_PATTERN","handleQuestion","question","match","exec","encoding","handleOpen","peek","handleCData","trim","uriMap","getPackages","reduce","on","obj","decodeStr","selfClosing","attrs","decodedAttrs","keys","d","key","decodeEntities","Promise","resolve","reject","parse","e","rootElement","defineProperty","XML_PREAMBLE","ESCAPE_ATTR_CHARS","ESCAPE_CHARS","Namespaces","parent","prefixMap","used","wellknown","custom","byUri","add","isWellknown","mapPrefix","uriByPrefix","getNSKey","logUsed","nsKey","getUsed","isUsed","self","allNs","concat","lower","string","toLowerCase","nameToAlias","inherits","ctor","superCtor","super_","constructor","enumerable","writable","configurable","nsName","getNsAttrs","namespaces","map","getElementNs","isGeneric","$pkg","getPropertyNs","getSerializableProperties","default","ESCAPE_ATTR_MAP","ESCAPE_MAP","escape","charPattern","replaceMap","replace","s","escapeAttr","escapeBody","filterAttributes","props","filterContained","ReferenceSerializer","tagName","build","serializeTo","writer","appendIndent","append","appendNewLine","BodySerializer","serializeValue","search","ValueSerializer","ElementSerializer","propertyDescriptor","elementDescriptor","otherAttrs","parseGeneric","parseNsAttributes","nsPropertyTagName","nsTagName","addTagName","parseAttributes","parseContainments","parseGenericAttributes","effectiveNs","logNamespaceUsed","isLocalNs","nsAttributeName","inherited","getNamespaces","val","nonNsAttr","child","parseNsAttribute","$model","logNamespace","actualNs","genericAttrs","$attrs","attr","addAttribute","console","warn","isBody","asType","asProperty","serializer","TypeSerializer","local","parentNamespaces","nsUri","nsPrefix","existing","newPrefix","wellknownUri","join","serializeAttributes","a","firstBody","indent","b","unindent","typeNs","SavingWriter","write","FormatingWriter","out","format","Writer","preamble","toXML","tree","internalWriter","formatingWriter"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/node_modules/moddle-xml/dist/index.esm.js"],"sourcesContent":["import { forEach, assign, find, filter, has, isString } from 'min-dash';\nimport { Parser } from 'saxen';\nimport { coerceType, parseNameNS, isSimpleType, Moddle } from 'moddle';\n\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\n\nvar DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\n\nvar XSI_TYPE = 'xsi:type';\n\nfunction serializeFormat(element) {\n  return element.xml && element.xml.serialize;\n}\n\nfunction serializeAsType(element) {\n  return serializeFormat(element) === XSI_TYPE;\n}\n\nfunction serializeAsProperty(element) {\n  return serializeFormat(element) === 'property';\n}\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction aliasToName(aliasNs, pkg) {\n\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\nfunction prefixedToName(nameNs, pkg) {\n\n  var name = nameNs.name,\n      localName = nameNs.localName;\n\n  var typePrefix = pkg.xml && pkg.xml.typePrefix;\n\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\n\nfunction normalizeXsiTypeName(name, model) {\n\n  var nameNs = parseNameNS(name);\n  var pkg = model.getPackage(nameNs.prefix);\n\n  return prefixedToName(nameNs, pkg);\n}\n\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nfunction Context(options) {\n\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  assign(this, options);\n\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function(reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function(element) {\n\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n\n    var descriptor = getModdleDescriptor(element);\n\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function(warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function() {};\nBaseHandler.prototype.handleText = function() {};\nBaseHandler.prototype.handleNode = function() {};\n\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() { }\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function() {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function(text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function(node) {\n\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function() {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function(node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function() {\n\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n\n  value = coerceType(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function(node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n\n/**\n * @class Reader.ElementHandler\n *\n */\nfunction ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\n\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function(reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleText = function(text) {\n\n  var element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n\n  BodyHandler.prototype.handleText.call(this, text);\n};\n\nElementHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function(node) {\n  var attributes = node.attributes,\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({}),\n      model = this.model,\n      propNameNs;\n\n  forEach(attributes, function(value, name) {\n\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n\n        forEach(values, function(v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else\n      if (name !== 'xmlns') {\n        propNameNs = parseNameNS(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n\n      instance.set(name, value);\n    }\n  });\n\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function(node) {\n\n  var name = node.name;\n  var nameNs = parseNameNS(name);\n\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName],\n      elementTypeName,\n      elementType;\n\n  // search for properties by name first\n\n  if (property && !property.isAttr) {\n\n    if (serializeAsType(property)) {\n      elementTypeName = node.attributes[XSI_TYPE];\n\n      // xsi type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\"\n        elementTypeName = normalizeXsiTypeName(elementTypeName, model);\n\n        elementType = model.getType(elementTypeName);\n\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    elementTypeName = aliasToName(nameNs, pkg);\n    elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function(p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function(p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function() {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function(type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function(node) {\n  var propertyDesc, type, element, childHandler;\n\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n\n      this.context.addReference(newElement);\n    } else {\n\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\n\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\nRootElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      nameNs = parseNameNS(name),\n      model = this.model,\n      type = this.type,\n      pkg = model.getPackage(nameNs.prefix),\n      typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n\n  return ElementHandler.prototype.createElement.call(this, node);\n};\n\n\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      ns = parseNameNS(name),\n      prefix = ns.prefix,\n      uri = node.ns[prefix + '$uri'],\n      attributes = node.attributes;\n\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function(node) {\n\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleEnd = function() {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nfunction Reader(options) {\n\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  assign(this, { lax: false }, options);\n}\n\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML result.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\nReader.prototype.fromXML = function(xml, options, done) {\n\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n\n  var context = new Context(assign({}, options, { rootHandler: rootHandler })),\n      parser = new Parser({ proxy: true }),\n      stack = createStack();\n\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n  function handleError(err, getContext, lax) {\n\n    var ctx = getContext();\n\n    var line = ctx.line,\n        column = ctx.column,\n        data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n\n    var message =\n      'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' +\n        'line: ' + line + '\\n\\t' +\n        'column: ' + column + '\\n\\t' +\n        'nested error: ' + err.message;\n\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n\n  function handleWarning(err, getContext) {\n\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\n   * Resolve collected references on parse end.\n   */\n  function resolveReferences() {\n\n    var elementsById = context.elementsById;\n    var references = context.references;\n\n    var i, r;\n\n    for (i = 0; (r = references[i]); i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n\n  var UTF_8_PATTERN = /^utf-8$/i;\n\n  function handleQuestion(question) {\n\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n\n    context.addWarning({\n      message:\n        'unsupported document encoding <' + encoding + '>, ' +\n        'falling back to UTF-8'\n    });\n  }\n\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n\n  function handleCData(text, getContext) {\n\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n\n  function handleText(text, getContext) {\n\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n\n    if (!text.trim()) {\n      return;\n    }\n\n    handleCData(text, getContext);\n  }\n\n  var uriMap = model.getPackages().reduce(function(uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n\n    return uriMap;\n  }, {\n    'http://www.w3.org/XML/1998/namespace': 'xml' // add default xml ns\n  });\n  parser\n    .ns(uriMap)\n    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {\n\n      // gracefully handle unparsable attributes (attrs=false)\n      var attrs = obj.attrs || {};\n\n      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\n        var value = decodeStr(attrs[key]);\n\n        d[key] = value;\n\n        return d;\n      }, {});\n\n      var node = {\n        name: obj.name,\n        originalName: obj.originalName,\n        attributes: decodedAttrs,\n        ns: obj.ns\n      };\n\n      handleOpen(node, getContext);\n    })\n    .on('question', handleQuestion)\n    .on('closeTag', handleClose)\n    .on('cdata', handleCData)\n    .on('text', function(text, decodeEntities, getContext) {\n      handleText(decodeEntities(text), getContext);\n    })\n    .on('error', handleError)\n    .on('warn', handleWarning);\n\n  // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n  return new Promise(function(resolve, reject) {\n\n    var err;\n\n    try {\n      parser.parse(xml);\n\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n\n    var rootElement = rootHandler.element;\n\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n\n    if (err) {\n      err.warnings = warnings;\n\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\n\nReader.prototype.handler = function(name) {\n  return new RootElementHandler(this.model, name);\n};\n\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n\n  Object.defineProperty(stack, 'peek', {\n    value: function() {\n      return this[this.length - 1];\n    }\n  });\n\n  return stack;\n}\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\n\n\nfunction Namespaces(parent) {\n\n  var prefixMap = {};\n  var uriMap = {};\n  var used = {};\n\n  var wellknown = [];\n  var custom = [];\n\n  // API\n\n  this.byUri = function(uri) {\n    return uriMap[uri] || (\n      parent && parent.byUri(uri)\n    );\n  };\n\n  this.add = function(ns, isWellknown) {\n\n    uriMap[ns.uri] = ns;\n\n    if (isWellknown) {\n      wellknown.push(ns);\n    } else {\n      custom.push(ns);\n    }\n\n    this.mapPrefix(ns.prefix, ns.uri);\n  };\n\n  this.uriByPrefix = function(prefix) {\n    return prefixMap[prefix || 'xmlns'];\n  };\n\n  this.mapPrefix = function(prefix, uri) {\n    prefixMap[prefix || 'xmlns'] = uri;\n  };\n\n  this.getNSKey = function(ns) {\n    return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;\n  };\n\n  this.logUsed = function(ns) {\n\n    var uri = ns.uri;\n    var nsKey = this.getNSKey(ns);\n\n    used[nsKey] = this.byUri(uri);\n\n    // Inform parent recursively about the usage of this NS\n    if (parent) {\n      parent.logUsed(ns);\n    }\n  };\n\n  this.getUsed = function(ns) {\n\n    function isUsed(ns) {\n      var nsKey = self.getNSKey(ns);\n\n      return used[nsKey];\n    }\n\n    var self = this;\n\n    var allNs = [].concat(wellknown, custom);\n\n    return allNs.filter(isUsed);\n  };\n\n}\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n\n  return namespaces.getUsed().filter(function(ns) {\n\n    // do not serialize built in <xml> namespace\n    return ns.prefix !== 'xml';\n  }).map(function(ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return { name: name, value: ns.uri };\n  });\n\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({ localName: descriptor.ns.localName }, ns);\n  } else {\n    return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return assign({ localName: descriptor.ns.localName }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n\n  return filter(descriptor.properties, function(p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!has(element, name)) {\n      return false;\n    }\n\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\n\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\n\nfunction escape(str, charPattern, replaceMap) {\n\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n\n  return str.replace(charPattern, function(s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\n\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\n\nfunction filterAttributes(props) {\n  return filter(props, function(p) { return p.isAttr; });\n}\n\nfunction filterContained(props) {\n  return filter(props, function(p) { return !p.isAttr; });\n}\n\n\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\n\nReferenceSerializer.prototype.build = function(element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function(writer) {\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue =\nBodySerializer.prototype.serializeTo = function(writer) {\n  writer.append(\n    this.escape\n      ? escapeBody(this.value)\n      : this.value\n  );\n};\n\nBodySerializer.prototype.build = function(prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function(writer) {\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>');\n\n  this.serializeValue(writer);\n\n  writer\n    .append('</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\n\nElementSerializer.prototype.build = function(element) {\n  this.element = element;\n\n  var elementDescriptor = element.$descriptor,\n      propertyDescriptor = this.propertyDescriptor;\n\n  var otherAttrs,\n      properties;\n\n  var isGeneric = elementDescriptor.isGeneric;\n\n  if (isGeneric) {\n    otherAttrs = this.parseGeneric(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n\n  if (!isGeneric) {\n    properties = getSerializableProperties(element);\n\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n\n  this.parseGenericAttributes(element, otherAttrs);\n\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function(element) {\n\n  var ns;\n\n  if (isString(element)) {\n    ns = parseNameNS(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return { localName: ns.localName };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return { localName: ns.localName };\n  } else {\n    return assign({ localName: ns.localName }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGeneric = function(element) {\n\n  var self = this,\n      body = this.body;\n\n  var attributes = [];\n\n  forEach(element, function(val, key) {\n\n    var nonNsAttr;\n\n    if (key === '$body') {\n      body.push(new BodySerializer().build({ type: 'String' }, val));\n    } else\n    if (key === '$children') {\n      forEach(val, function(child) {\n        body.push(new ElementSerializer(self).build(child));\n      });\n    } else\n    if (key.indexOf('$') !== 0) {\n      nonNsAttr = self.parseNsAttribute(element, key, val);\n\n      if (nonNsAttr) {\n        attributes.push({ name: key, value: val });\n      }\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\n  var model = element.$model;\n\n  var nameNs = parseNameNS(name);\n\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = { prefix: nameNs.localName, uri: value };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = { uri: value };\n  }\n\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  if (model && model.getPackage(value)) {\n\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function(element, attrs) {\n  var self = this;\n\n  var genericAttrs = element.$attrs;\n\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function(value, name) {\n\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n  var self = this;\n\n  forEach(attributes, function(attr) {\n\n    // do not serialize xsi:type attribute\n    // it is set manually based on the actual implementation type\n    if (attr.name === XSI_TYPE) {\n      return;\n    }\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      console.warn(\n        'missing namespace information for ',\n        attr.name, '=', attr.value, 'on', element,\n        e);\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function(properties) {\n\n  var self = this,\n      body = this.body,\n      element = this.element;\n\n  forEach(properties, function(p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    if (!isMany) {\n      value = [ value ];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else\n    if (isSimpleType(p.type)) {\n      forEach(value, function(v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else\n    if (isReference) {\n      forEach(value, function(v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n\n      // allow serialization via type\n      // rather than element name\n      var asType = serializeAsType(p),\n          asProperty = serializeAsProperty(p);\n\n      forEach(value, function(v) {\n        var serializer;\n\n        if (asType) {\n          serializer = new TypeSerializer(self, p);\n        } else\n        if (asProperty) {\n          serializer = new ElementSerializer(self, p);\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function(local) {\n\n  var namespaces = this.namespaces,\n      parent = this.parent,\n      parentNamespaces;\n\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n\n  var nsUri = ns.uri,\n      nsPrefix = ns.prefix;\n\n  var existing = namespaces.byUri(nsUri);\n\n  if (!existing || local) {\n    namespaces.add(ns, wellknown);\n  }\n\n  namespaces.mapPrefix(nsPrefix, nsUri);\n\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\n  var element = this.element,\n      model = element.$model,\n      namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n      uri = ns.uri,\n      newPrefix, idx,\n      wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return { localName: ns.localName };\n  }\n\n  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n\n  ns = namespaces.byUri(uri);\n\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n\n    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\n  }\n\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function(properties) {\n  var self = this,\n      element = this.element;\n\n  forEach(properties, function(p) {\n\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n\n      if (!p.isMany) {\n        value = value.id;\n      }\n      else {\n        var values = [];\n        forEach(value, function(v) {\n          values.push(v.id);\n        });\n\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addTagName = function(nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n\n  this.getNamespaces().logUsed(actualNs);\n\n  return nsName(nsTagName);\n};\n\nElementSerializer.prototype.addAttribute = function(name, value) {\n  var attrs = this.attrs;\n\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  attrs.push({ name: name, value: value });\n};\n\nElementSerializer.prototype.serializeAttributes = function(writer) {\n  var attrs = this.attrs,\n      namespaces = this.namespaces;\n\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n\n  forEach(attrs, function(a) {\n    writer\n      .append(' ')\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function(writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName);\n\n  this.serializeAttributes(writer);\n\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n\n    if (indent) {\n      writer\n        .appendNewLine()\n        .indent();\n    }\n\n    forEach(this.body, function(b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer\n        .unindent()\n        .appendIndent();\n    }\n\n    writer.append('</' + this.tagName + '>');\n  }\n\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, propertyDescriptor) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.parseNsAttributes = function(element) {\n\n  // extracted attributes\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);\n\n  var descriptor = element.$descriptor;\n\n  // only serialize xsi:type if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n  this.addAttribute(\n    this.nsAttributeName(XSI_TYPE),\n    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName\n  );\n\n  return attributes;\n};\n\nTypeSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function(str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n\n  var indent = [''];\n\n  this.append = function(str) {\n    out.write(str);\n\n    return this;\n  };\n\n  this.appendNewLine = function() {\n    if (format) {\n      out.write('\\n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function() {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function() {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function() {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nfunction Writer(options) {\n\n  options = assign({ format: false, preamble: true }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}\n\nexport { Reader, Writer };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}