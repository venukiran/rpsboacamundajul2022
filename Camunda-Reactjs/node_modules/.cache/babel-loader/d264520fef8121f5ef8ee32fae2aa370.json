{"ast":null,"code":"import { isObject, sortBy } from 'min-dash';\nimport { pointDistance, pointsOnLine } from '../util/Geometry';\nimport intersectPaths from 'path-intersection';\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\nexport function roundPoint(point) {\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Object}\n */\n\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {Object} trbl\n *\n * @return {Bounds}\n */\n\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Point}\n */\n\nexport function getMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n} // orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Bounds} rect\n * @param {Bounds} reference\n * @param {Point|number} padding\n *\n * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\n\nexport function getOrientation(rect, reference, padding) {\n  padding = padding || 0; // make sure we can use an object, too\n  // for individual { x, y } padding\n\n  if (!isObject(padding)) {\n    padding = {\n      x: padding,\n      y: padding\n    };\n  }\n\n  var rectOrientation = asTRBL(rect),\n      referenceOrientation = asTRBL(reference);\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\n  var vertical = top ? 'top' : bottom ? 'bottom' : null,\n      horizontal = left ? 'left' : right ? 'right' : null;\n\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n} // intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {PathDef} elementPath\n * @param {PathDef} linePath\n * @param {boolean} cropStart crop from start or end\n *\n * @return {Point}\n */\n\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n  var intersections = getIntersections(elementPath, linePath); // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function (i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n      distance = 100 - distance;\n      distance = (distance < 10 ? '0' : '') + distance; // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n\n      return i.segment2 + '#' + distance;\n    });\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n\n  return null;\n}\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}\nexport function filterRedundantWaypoints(waypoints) {\n  // alter copy of waypoints, not original\n  waypoints = waypoints.slice();\n  var idx = 0,\n      point,\n      previousPoint,\n      nextPoint;\n\n  while (waypoints[idx]) {\n    point = waypoints[idx];\n    previousPoint = waypoints[idx - 1];\n    nextPoint = waypoints[idx + 1];\n\n    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {\n      // remove point, if overlapping with {nextPoint}\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\n      waypoints.splice(idx, 1);\n    } else {\n      idx++;\n    }\n  }\n\n  return waypoints;\n}","map":{"version":3,"names":["isObject","sortBy","pointDistance","pointsOnLine","intersectPaths","roundBounds","bounds","x","Math","round","y","width","height","roundPoint","point","asTRBL","top","right","bottom","left","asBounds","trbl","getMid","getOrientation","rect","reference","padding","rectOrientation","referenceOrientation","vertical","horizontal","getElementLineIntersection","elementPath","linePath","cropStart","intersections","getIntersections","length","i","distance","floor","t2","segment2","a","b","filterRedundantWaypoints","waypoints","slice","idx","previousPoint","nextPoint","splice"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/node_modules/diagram-js/lib/layout/LayoutUtil.js"],"sourcesContent":["import {\n  isObject,\n  sortBy\n} from 'min-dash';\n\nimport {\n  pointDistance,\n  pointsOnLine\n} from '../util/Geometry';\n\nimport intersectPaths from 'path-intersection';\n\n\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\n\n\nexport function roundPoint(point) {\n\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n\n\n/**\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Object}\n */\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n\n\n/**\n * Convert a { top, left, bottom, right } to an objects bounds.\n *\n * @param {Object} trbl\n *\n * @return {Bounds}\n */\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n\n\n/**\n * Get the mid of the given bounds or point.\n *\n * @param {Bounds|Point} bounds\n *\n * @return {Point}\n */\nexport function getMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n\n\n// orientation utils //////////////////////\n\n/**\n * Get orientation of the given rectangle with respect to\n * the reference rectangle.\n *\n * A padding (positive or negative) may be passed to influence\n * horizontal / vertical orientation and intersection.\n *\n * @param {Bounds} rect\n * @param {Bounds} reference\n * @param {Point|number} padding\n *\n * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\n */\nexport function getOrientation(rect, reference, padding) {\n\n  padding = padding || 0;\n\n  // make sure we can use an object, too\n  // for individual { x, y } padding\n  if (!isObject(padding)) {\n    padding = { x: padding, y: padding };\n  }\n\n\n  var rectOrientation = asTRBL(rect),\n      referenceOrientation = asTRBL(reference);\n\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\n\n  var vertical = top ? 'top' : (bottom ? 'bottom' : null),\n      horizontal = left ? 'left' : (right ? 'right' : null);\n\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n}\n\n\n// intersection utils //////////////////////\n\n/**\n * Get intersection between an element and a line path.\n *\n * @param {PathDef} elementPath\n * @param {PathDef} linePath\n * @param {boolean} cropStart crop from start or end\n *\n * @return {Point}\n */\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n\n  var intersections = getIntersections(elementPath, linePath);\n\n  // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function(i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n\n      distance = 100 - distance;\n\n      distance = (distance < 10 ? '0' : '') + distance;\n\n      // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n      return i.segment2 + '#' + distance;\n    });\n\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n\n  return null;\n}\n\n\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}\n\n\nexport function filterRedundantWaypoints(waypoints) {\n\n  // alter copy of waypoints, not original\n  waypoints = waypoints.slice();\n\n  var idx = 0,\n      point,\n      previousPoint,\n      nextPoint;\n\n  while (waypoints[idx]) {\n    point = waypoints[idx];\n    previousPoint = waypoints[idx - 1];\n    nextPoint = waypoints[idx + 1];\n\n    if (pointDistance(point, nextPoint) === 0 ||\n        pointsOnLine(previousPoint, nextPoint, point)) {\n\n      // remove point, if overlapping with {nextPoint}\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\n      waypoints.splice(idx, 1);\n    } else {\n      idx++;\n    }\n  }\n\n  return waypoints;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}