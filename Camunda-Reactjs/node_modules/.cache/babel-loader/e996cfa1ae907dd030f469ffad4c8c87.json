{"ast":null,"code":"import { isObject, assign, forEach, reduce } from 'min-dash';\nimport { append as svgAppend, attr as svgAttr, create as svgCreate, remove as svgRemove } from 'tiny-svg';\nvar DEFAULT_BOX_PADDING = 0;\nvar DEFAULT_LABEL_SIZE = {\n  width: 150,\n  height: 50\n};\n\nfunction parseAlign(align) {\n  var parts = align.split('-');\n  return {\n    horizontal: parts[0] || 'center',\n    vertical: parts[1] || 'top'\n  };\n}\n\nfunction parsePadding(padding) {\n  if (isObject(padding)) {\n    return assign({\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    }, padding);\n  } else {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding\n    };\n  }\n}\n\nfunction getTextBBox(text, fakeText) {\n  fakeText.textContent = text;\n  var textBBox;\n\n  try {\n    var bbox,\n        emptyLine = text === ''; // add dummy text, when line is empty to\n    // determine correct height\n\n    fakeText.textContent = emptyLine ? 'dummy' : text;\n    textBBox = fakeText.getBBox(); // take text rendering related horizontal\n    // padding into account\n\n    bbox = {\n      width: textBBox.width + textBBox.x * 2,\n      height: textBBox.height\n    };\n\n    if (emptyLine) {\n      // correct width\n      bbox.width = 0;\n    }\n\n    return bbox;\n  } catch (e) {\n    return {\n      width: 0,\n      height: 0\n    };\n  }\n}\n/**\n * Layout the next line and return the layouted element.\n *\n * Alters the lines passed.\n *\n * @param  {Array<string>} lines\n * @return {Object} the line descriptor, an object { width, height, text }\n */\n\n\nfunction layoutNext(lines, maxWidth, fakeText) {\n  var originalLine = lines.shift(),\n      fitLine = originalLine;\n  var textBBox;\n\n  for (;;) {\n    textBBox = getTextBBox(fitLine, fakeText);\n    textBBox.width = fitLine ? textBBox.width : 0; // try to fit\n\n    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {\n      return fit(lines, fitLine, originalLine, textBBox);\n    }\n\n    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\n  }\n}\n\nfunction fit(lines, fitLine, originalLine, textBBox) {\n  if (fitLine.length < originalLine.length) {\n    var remainder = originalLine.slice(fitLine.length).trim();\n    lines.unshift(remainder);\n  }\n\n  return {\n    width: textBBox.width,\n    height: textBBox.height,\n    text: fitLine\n  };\n}\n\nvar SOFT_BREAK = '\\u00AD';\n/**\n * Shortens a line based on spacing and hyphens.\n * Returns the shortened result on success.\n *\n * @param  {string} line\n * @param  {number} maxLength the maximum characters of the string\n * @return {string} the shortened string\n */\n\nfunction semanticShorten(line, maxLength) {\n  var parts = line.split(/(\\s|-|\\u00AD)/g),\n      part,\n      shortenedParts = [],\n      length = 0; // try to shorten via break chars\n\n  if (parts.length > 1) {\n    while (part = parts.shift()) {\n      if (part.length + length < maxLength) {\n        shortenedParts.push(part);\n        length += part.length;\n      } else {\n        // remove previous part, too if hyphen does not fit anymore\n        if (part === '-' || part === SOFT_BREAK) {\n          shortenedParts.pop();\n        }\n\n        break;\n      }\n    }\n  }\n\n  var last = shortenedParts[shortenedParts.length - 1]; // translate trailing soft break to actual hyphen\n\n  if (last && last === SOFT_BREAK) {\n    shortenedParts[shortenedParts.length - 1] = '-';\n  }\n\n  return shortenedParts.join('');\n}\n\nfunction shortenLine(line, width, maxWidth) {\n  var length = Math.max(line.length * (maxWidth / width), 1); // try to shorten semantically (i.e. based on spaces and hyphens)\n\n  var shortenedLine = semanticShorten(line, length);\n\n  if (!shortenedLine) {\n    // force shorten by cutting the long word\n    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\n  }\n\n  return shortenedLine;\n}\n\nfunction getHelperSvg() {\n  var helperSvg = document.getElementById('helper-svg');\n\n  if (!helperSvg) {\n    helperSvg = svgCreate('svg');\n    svgAttr(helperSvg, {\n      id: 'helper-svg',\n      width: 0,\n      height: 0,\n      style: 'visibility: hidden; position: fixed'\n    });\n    document.body.appendChild(helperSvg);\n  }\n\n  return helperSvg;\n}\n/**\n * Creates a new label utility\n *\n * @param {Object} config\n * @param {Dimensions} config.size\n * @param {number} config.padding\n * @param {Object} config.style\n * @param {string} config.align\n */\n\n\nexport default function Text(config) {\n  this._config = assign({}, {\n    size: DEFAULT_LABEL_SIZE,\n    padding: DEFAULT_BOX_PADDING,\n    style: {},\n    align: 'center-top'\n  }, config || {});\n}\n/**\n * Returns the layouted text as an SVG element.\n *\n * @param {string} text\n * @param {Object} options\n *\n * @return {SVGElement}\n */\n\nText.prototype.createText = function (text, options) {\n  return this.layoutText(text, options).element;\n};\n/**\n * Returns a labels layouted dimensions.\n *\n * @param {string} text to layout\n * @param {Object} options\n *\n * @return {Dimensions}\n */\n\n\nText.prototype.getDimensions = function (text, options) {\n  return this.layoutText(text, options).dimensions;\n};\n/**\n * Creates and returns a label and its bounding box.\n *\n * @method Text#createText\n *\n * @param {string} text the text to render on the label\n * @param {Object} options\n * @param {string} options.align how to align in the bounding box.\n *                               Any of { 'center-middle', 'center-top' },\n *                               defaults to 'center-top'.\n * @param {string} options.style style to be applied to the text\n * @param {boolean} options.fitBox indicates if box will be recalculated to\n *                                 fit text\n *\n * @return {Object} { element, dimensions }\n */\n\n\nText.prototype.layoutText = function (text, options) {\n  var box = assign({}, this._config.size, options.box),\n      style = assign({}, this._config.style, options.style),\n      align = parseAlign(options.align || this._config.align),\n      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),\n      fitBox = options.fitBox || false;\n  var lineHeight = getLineHeight(style); // we split text by lines and normalize\n  // {soft break} + {line break} => { line break }\n\n  var lines = text.split(/\\u00AD?\\r?\\n/),\n      layouted = [];\n  var maxWidth = box.width - padding.left - padding.right; // ensure correct rendering by attaching helper text node to invisible SVG\n\n  var helperText = svgCreate('text');\n  svgAttr(helperText, {\n    x: 0,\n    y: 0\n  });\n  svgAttr(helperText, style);\n  var helperSvg = getHelperSvg();\n  svgAppend(helperSvg, helperText);\n\n  while (lines.length) {\n    layouted.push(layoutNext(lines, maxWidth, helperText));\n  }\n\n  if (align.vertical === 'middle') {\n    padding.top = padding.bottom = 0;\n  }\n\n  var totalHeight = reduce(layouted, function (sum, line, idx) {\n    return sum + (lineHeight || line.height);\n  }, 0) + padding.top + padding.bottom;\n  var maxLineWidth = reduce(layouted, function (sum, line, idx) {\n    return line.width > sum ? line.width : sum;\n  }, 0); // the y position of the next line\n\n  var y = padding.top;\n\n  if (align.vertical === 'middle') {\n    y += (box.height - totalHeight) / 2;\n  } // magic number initial offset\n\n\n  y -= (lineHeight || layouted[0].height) / 4;\n  var textElement = svgCreate('text');\n  svgAttr(textElement, style); // layout each line taking into account that parent\n  // shape might resize to fit text size\n\n  forEach(layouted, function (line) {\n    var x;\n    y += lineHeight || line.height;\n\n    switch (align.horizontal) {\n      case 'left':\n        x = padding.left;\n        break;\n\n      case 'right':\n        x = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;\n        break;\n\n      default:\n        // aka center\n        x = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);\n    }\n\n    var tspan = svgCreate('tspan');\n    svgAttr(tspan, {\n      x: x,\n      y: y\n    });\n    tspan.textContent = line.text;\n    svgAppend(textElement, tspan);\n  });\n  svgRemove(helperText);\n  var dimensions = {\n    width: maxLineWidth,\n    height: totalHeight\n  };\n  return {\n    dimensions: dimensions,\n    element: textElement\n  };\n};\n\nfunction getLineHeight(style) {\n  if ('fontSize' in style && 'lineHeight' in style) {\n    return style.lineHeight * parseInt(style.fontSize, 10);\n  }\n}","map":{"version":3,"names":["isObject","assign","forEach","reduce","append","svgAppend","attr","svgAttr","create","svgCreate","remove","svgRemove","DEFAULT_BOX_PADDING","DEFAULT_LABEL_SIZE","width","height","parseAlign","align","parts","split","horizontal","vertical","parsePadding","padding","top","left","right","bottom","getTextBBox","text","fakeText","textContent","textBBox","bbox","emptyLine","getBBox","x","e","layoutNext","lines","maxWidth","originalLine","shift","fitLine","Math","round","length","fit","shortenLine","remainder","slice","trim","unshift","SOFT_BREAK","semanticShorten","line","maxLength","part","shortenedParts","push","pop","last","join","max","shortenedLine","getHelperSvg","helperSvg","document","getElementById","id","style","body","appendChild","Text","config","_config","size","prototype","createText","options","layoutText","element","getDimensions","dimensions","box","undefined","fitBox","lineHeight","getLineHeight","layouted","helperText","y","totalHeight","sum","idx","maxLineWidth","textElement","tspan","parseInt","fontSize"],"sources":["D:/projects/Camunda/rpsboacamundajul2022/Camunda-Reactjs/node_modules/diagram-js/lib/util/Text.js"],"sourcesContent":["import {\n  isObject,\n  assign,\n  forEach,\n  reduce\n} from 'min-dash';\n\nimport {\n  append as svgAppend,\n  attr as svgAttr,\n  create as svgCreate,\n  remove as svgRemove\n} from 'tiny-svg';\n\nvar DEFAULT_BOX_PADDING = 0;\n\nvar DEFAULT_LABEL_SIZE = {\n  width: 150,\n  height: 50\n};\n\n\nfunction parseAlign(align) {\n\n  var parts = align.split('-');\n\n  return {\n    horizontal: parts[0] || 'center',\n    vertical: parts[1] || 'top'\n  };\n}\n\nfunction parsePadding(padding) {\n\n  if (isObject(padding)) {\n    return assign({ top: 0, left: 0, right: 0, bottom: 0 }, padding);\n  } else {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding\n    };\n  }\n}\n\nfunction getTextBBox(text, fakeText) {\n\n  fakeText.textContent = text;\n\n  var textBBox;\n\n  try {\n    var bbox,\n        emptyLine = text === '';\n\n    // add dummy text, when line is empty to\n    // determine correct height\n    fakeText.textContent = emptyLine ? 'dummy' : text;\n\n    textBBox = fakeText.getBBox();\n\n    // take text rendering related horizontal\n    // padding into account\n    bbox = {\n      width: textBBox.width + textBBox.x * 2,\n      height: textBBox.height\n    };\n\n    if (emptyLine) {\n\n      // correct width\n      bbox.width = 0;\n    }\n\n    return bbox;\n  } catch (e) {\n    return { width: 0, height: 0 };\n  }\n}\n\n\n/**\n * Layout the next line and return the layouted element.\n *\n * Alters the lines passed.\n *\n * @param  {Array<string>} lines\n * @return {Object} the line descriptor, an object { width, height, text }\n */\nfunction layoutNext(lines, maxWidth, fakeText) {\n\n  var originalLine = lines.shift(),\n      fitLine = originalLine;\n\n  var textBBox;\n\n  for (;;) {\n    textBBox = getTextBBox(fitLine, fakeText);\n\n    textBBox.width = fitLine ? textBBox.width : 0;\n\n    // try to fit\n    if (fitLine === ' ' || fitLine === '' || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {\n      return fit(lines, fitLine, originalLine, textBBox);\n    }\n\n    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);\n  }\n}\n\nfunction fit(lines, fitLine, originalLine, textBBox) {\n  if (fitLine.length < originalLine.length) {\n    var remainder = originalLine.slice(fitLine.length).trim();\n\n    lines.unshift(remainder);\n  }\n\n  return {\n    width: textBBox.width,\n    height: textBBox.height,\n    text: fitLine\n  };\n}\n\nvar SOFT_BREAK = '\\u00AD';\n\n\n/**\n * Shortens a line based on spacing and hyphens.\n * Returns the shortened result on success.\n *\n * @param  {string} line\n * @param  {number} maxLength the maximum characters of the string\n * @return {string} the shortened string\n */\nfunction semanticShorten(line, maxLength) {\n\n  var parts = line.split(/(\\s|-|\\u00AD)/g),\n      part,\n      shortenedParts = [],\n      length = 0;\n\n  // try to shorten via break chars\n  if (parts.length > 1) {\n\n    while ((part = parts.shift())) {\n      if (part.length + length < maxLength) {\n        shortenedParts.push(part);\n        length += part.length;\n      } else {\n\n        // remove previous part, too if hyphen does not fit anymore\n        if (part === '-' || part === SOFT_BREAK) {\n          shortenedParts.pop();\n        }\n\n        break;\n      }\n    }\n  }\n\n  var last = shortenedParts[shortenedParts.length - 1];\n\n  // translate trailing soft break to actual hyphen\n  if (last && last === SOFT_BREAK) {\n    shortenedParts[shortenedParts.length - 1] = '-';\n  }\n\n  return shortenedParts.join('');\n}\n\n\nfunction shortenLine(line, width, maxWidth) {\n  var length = Math.max(line.length * (maxWidth / width), 1);\n\n  // try to shorten semantically (i.e. based on spaces and hyphens)\n  var shortenedLine = semanticShorten(line, length);\n\n  if (!shortenedLine) {\n\n    // force shorten by cutting the long word\n    shortenedLine = line.slice(0, Math.max(Math.round(length - 1), 1));\n  }\n\n  return shortenedLine;\n}\n\n\nfunction getHelperSvg() {\n  var helperSvg = document.getElementById('helper-svg');\n\n  if (!helperSvg) {\n    helperSvg = svgCreate('svg');\n\n    svgAttr(helperSvg, {\n      id: 'helper-svg',\n      width: 0,\n      height: 0,\n      style: 'visibility: hidden; position: fixed'\n    });\n\n    document.body.appendChild(helperSvg);\n  }\n\n  return helperSvg;\n}\n\n\n/**\n * Creates a new label utility\n *\n * @param {Object} config\n * @param {Dimensions} config.size\n * @param {number} config.padding\n * @param {Object} config.style\n * @param {string} config.align\n */\nexport default function Text(config) {\n\n  this._config = assign({}, {\n    size: DEFAULT_LABEL_SIZE,\n    padding: DEFAULT_BOX_PADDING,\n    style: {},\n    align: 'center-top'\n  }, config || {});\n}\n\n/**\n * Returns the layouted text as an SVG element.\n *\n * @param {string} text\n * @param {Object} options\n *\n * @return {SVGElement}\n */\nText.prototype.createText = function(text, options) {\n  return this.layoutText(text, options).element;\n};\n\n/**\n * Returns a labels layouted dimensions.\n *\n * @param {string} text to layout\n * @param {Object} options\n *\n * @return {Dimensions}\n */\nText.prototype.getDimensions = function(text, options) {\n  return this.layoutText(text, options).dimensions;\n};\n\n/**\n * Creates and returns a label and its bounding box.\n *\n * @method Text#createText\n *\n * @param {string} text the text to render on the label\n * @param {Object} options\n * @param {string} options.align how to align in the bounding box.\n *                               Any of { 'center-middle', 'center-top' },\n *                               defaults to 'center-top'.\n * @param {string} options.style style to be applied to the text\n * @param {boolean} options.fitBox indicates if box will be recalculated to\n *                                 fit text\n *\n * @return {Object} { element, dimensions }\n */\nText.prototype.layoutText = function(text, options) {\n  var box = assign({}, this._config.size, options.box),\n      style = assign({}, this._config.style, options.style),\n      align = parseAlign(options.align || this._config.align),\n      padding = parsePadding(options.padding !== undefined ? options.padding : this._config.padding),\n      fitBox = options.fitBox || false;\n\n  var lineHeight = getLineHeight(style);\n\n  // we split text by lines and normalize\n  // {soft break} + {line break} => { line break }\n  var lines = text.split(/\\u00AD?\\r?\\n/),\n      layouted = [];\n\n  var maxWidth = box.width - padding.left - padding.right;\n\n  // ensure correct rendering by attaching helper text node to invisible SVG\n  var helperText = svgCreate('text');\n  svgAttr(helperText, { x: 0, y: 0 });\n  svgAttr(helperText, style);\n\n  var helperSvg = getHelperSvg();\n\n  svgAppend(helperSvg, helperText);\n\n  while (lines.length) {\n    layouted.push(layoutNext(lines, maxWidth, helperText));\n  }\n\n  if (align.vertical === 'middle') {\n    padding.top = padding.bottom = 0;\n  }\n\n  var totalHeight = reduce(layouted, function(sum, line, idx) {\n    return sum + (lineHeight || line.height);\n  }, 0) + padding.top + padding.bottom;\n\n  var maxLineWidth = reduce(layouted, function(sum, line, idx) {\n    return line.width > sum ? line.width : sum;\n  }, 0);\n\n  // the y position of the next line\n  var y = padding.top;\n\n  if (align.vertical === 'middle') {\n    y += (box.height - totalHeight) / 2;\n  }\n\n  // magic number initial offset\n  y -= (lineHeight || layouted[0].height) / 4;\n\n\n  var textElement = svgCreate('text');\n\n  svgAttr(textElement, style);\n\n  // layout each line taking into account that parent\n  // shape might resize to fit text size\n  forEach(layouted, function(line) {\n\n    var x;\n\n    y += (lineHeight || line.height);\n\n    switch (align.horizontal) {\n    case 'left':\n      x = padding.left;\n      break;\n\n    case 'right':\n      x = ((fitBox ? maxLineWidth : maxWidth)\n        - padding.right - line.width);\n      break;\n\n    default:\n\n      // aka center\n      x = Math.max((((fitBox ? maxLineWidth : maxWidth)\n        - line.width) / 2 + padding.left), 0);\n    }\n\n    var tspan = svgCreate('tspan');\n    svgAttr(tspan, { x: x, y: y });\n\n    tspan.textContent = line.text;\n\n    svgAppend(textElement, tspan);\n  });\n\n  svgRemove(helperText);\n\n  var dimensions = {\n    width: maxLineWidth,\n    height: totalHeight\n  };\n\n  return {\n    dimensions: dimensions,\n    element: textElement\n  };\n};\n\n\nfunction getLineHeight(style) {\n  if ('fontSize' in style && 'lineHeight' in style) {\n    return style.lineHeight * parseInt(style.fontSize, 10);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}